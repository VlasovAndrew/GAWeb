\documentclass[bachelor, och, autoref, times]{SCWorks}
% параметр - тип обучения - одно из значений:
%    spec     - специальность
%    bachelor - бакалавриат (по умолчанию)
%    master   - магистратура
% параметр - форма обучения - одно из значений:
%    och   - очное (по умолчанию)
%    zaoch - заочное
% параметр - тип работы - одно из значений:
%    referat    - реферат
%    coursework - курсовая работа (по умолчанию)
%    diploma    - дипломная работа
%    pract      - отчет по практике
%    pract      - отчет о научно-исследовательской работе
%    autoref    - автореферат выпускной работы
%    assignment - задание на выпускную квалификационную работу
%    review     - отзыв руководителя
%    critique   - рецензия на выпускную работу
% параметр - включение шрифта
%    times    - включение шрифта Times New Roman (если установлен)
%               по умолчанию выключен
\usepackage[T2A]{fontenc}
\usepackage[cp1251]{inputenc}
\usepackage{graphicx}

\usepackage[sort,compress]{cite}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{fancyvrb}
\usepackage{longtable}
\usepackage{array}
\usepackage[english,russian]{babel}
\usepackage{pgfplots}
\usepackage{booktabs}
\usepackage{listings}
\usepackage{algorithm2e}

\usepackage[colorlinks=true]{hyperref}

\newcommand{\eqdef}{\stackrel {\rm def}{=}}

\newtheorem{lem}{Лемма}
\newcommand{\scale}{0.6}
\newcommand{\boxscale}{0.93}

\newcommand{\scaleWindow}{0.35}


\SetKwProg{Fn}{Function}{}{end}
\SetKwFunction{FnMutation}{Mutation}
\SetKwFunction{FnCrossover}{Crossover}
\SetKwFunction{FnSelection}{Selection}

\lstset{
	breaklines=true, 
	language=C, 
	numberstyle=\tiny, 
	numbers=left, 
	columns=flexible,
	keepspaces=false, 
	basicstyle=\small,
}


\begin{document}

% Кафедра (в родительном падеже)
\chair{математической кибернетики и компьютерных наук}

% Тема работы
\title{Исследование параметров генетического алгоритма для поиска центральных вершин в графах}

% Курс
\course{4}

% Группа
\group{411}

% Факультет (в родительном падеже) (по умолчанию "факультета КНиИТ")
%\department{факультета КНиИТ}

% Специальность/направление код - наименование
\napravlenie{02.03.02 "--- Фундаментальная информатика и информационные технологии}
%\napravlenie{02.03.01 "--- Математическое обеспечение и администрирование информационных систем}
%\napravlenie{09.03.01 "--- Информатика и вычислительная техника}
%\napravlenie{09.03.04 "--- Программная инженерия}
%\napravlenie{10.05.01 "--- Компьютерная безопасность}

% Для студентки. Для работы студента следующая команда не нужна.
%\studenttitle{Студентки}

% Фамилия, имя, отчество в родительном падеже
\author{Власова Андрея Александровича}

% Заведующий кафедрой
\chtitle{к.\,ф.-м.\,н., доцент}
\chname{А.\,С.\,Иванов}

%Научный руководитель (для реферата преподаватель проверяющий работу)
\satitle{доцент, к.\,ф.-м.\,н.} %должность, степень, звание
\saname{С.\,В.\,Миронов}

% Год выполнения отчета
\date{2020}

\maketitle

% Включение нумерации рисунков, формул и таблиц по разделам
% (по умолчанию - нумерация сквозная)
% (допускается оба вида нумерации)
%\secNumbering

\tableofcontents

% Раздел "Обозначения и сокращения". Может отсутствовать в работе
%\abbreviations

% Раздел "Определения". Может отсутствовать в работе
%\definitions

% Раздел "Определения, обозначения и сокращения". Может отсутствовать в работе.
% Если присутствует, то заменяет собой разделы "Обозначения и сокращения" и "Определения"
%\defabbr


% Раздел "Введение"
\intro
В современных компьютерных науках одно из центральных мест занимает математическая модель графа. Графовая модель позволяет 
описывать целый ряд систем и 
явлений, которые встречаются в различных предметных областях. Изучение структуры того или иного графа, или же выявление его 
свойств и особенностей может приносить невероятную практическую пользу. В связи с этим работы, посвященные этой теме, 
вызывают наибольший интерес как со стороны исследователей теоретиков, так и со стороны практиков. 

Одной из важных характеристик любого графа можно назвать радиус графа и расположение его центральных вершин. Получив данные 
параметры, можно судить об общей структуре графа или же о его особенностях. Современные графовые модели могут насчитывать 
десятки сотен тысяч вершин, поэтому для эффективного решения задач зачастую бывает недостаточно использовать классические 
алгоритмы, а необходимо реализовать некоторый эвристический подход, одним из которых является генетический алгоритм.

Основной целью работы было следующее "--- разработать и исследовать генетический алгоритм, 
способный решать задачу поиска центральных вершин.
Для достижения этой цели были поставлены следующие задачи:
\begin{itemize}
	\item реализовать идеи генетических алгоритмов с учетом рассматриваемой задачи,
	\item реализовать существующие алгоритмы для поиска центральных вершин,
	\item создать программное приложение, позволяющее проводить запуски алгоритма с различными параметрами,
	\item исследовать параметры алгоритма и выявить его слабые и сильные стороны.
\end{itemize}
 
\section{Описание задачи и алгоритмы для ее решения}
Для описания задачи сначала необходимо дать формальное определение понятию граф. 
Граф "--- это упорядоченная пара множеств $(V, E)$, где $V$ "--- множество вершин графа,
а $E$ "--- множество упорядоченных и неупорядоченных пар вершин "--- дуг или ребер. 
В случае, когда вершины в парах упорядочены, говорят, что граф является ориентированным, иначе "--- неориентированным.

В случает неориентированного графа также используется понятие связности графа "--- граф является связным, если между любой 
парой вершин существует по крайней мере один путь.
Кроме этого графы можно разделить на взвешенные или невзвешенные "--- в случае взвешенного графа каждое ребро имеет 
некоторый вес "--- положительное или отрицательное число, в случае невзвешенного графа каждое ребро имеет вес равный единице.

В данной работе рассматривается задача поиска центральных вершин в графах.
Для начала можно дать определение эксцентриситета вершины. Эксцентриситетом вершины называется максимальное из 
расстояний от этой вершины до всех остальных вершин в графе.
С использованием этого определения можно сказать, что центральными вершинами в графе называются вершины с минимальным 
значением эксцентриситета, при чем само значение этого минимального эксцентриситета представляет собой радиус графа.

Радиус графа и эксцентриситет вершины являются одними из базовых параметров, которые наиболее часто встречаются в прикладных задачах, либо необходимы при исследовании свойств графа \cite{DIAMETR1, SMALL_WORLD}. Этим объясняется довольно большое количество работ, в которых изучается данная задача.

\subsection{Тривиальный алгоритм}
Легко заметить, что задача поиска центральных вершин может быть с легкостью решена при 
использовании алгоритма обхода в ширину. Для того, чтобы найти вершину с минимальным эксцентриситетом
необходимо запустить обход в ширину из каждой вершины графа, после чего станут известны все длины путей между всеми вершинами
в графе. Алгоритм поиска в ширину имеет ассимптотическое время работы равное $O(n + m)$ \cite{CORMEN}.
При этом, если запустить его из каждой вершины, то время работы всего алгоритма будет равным $O(n^2 + nm)$.

\subsection{Алгоритмы с улучшенной ассимптотикой}
Кроме этого данная задача была хорошо изучена различными исследователями \cite{APSP, Fast_Approximation, Fast_Radius}, которые 
предлагали несколько подходов, 
для решения подобных задач.
Например, в работе \cite{Aingworth} предлагается алгоритм, использующий эвристику разделения вершин на два множества "--- множество 
вершин с высокой степенью и множество вершин с низкой степенью. После такого разделения для множества с вершинами с высокой 
степенью строится доминирующее множество, после чего из этого множества запускаются обходы в ширину.
Кроме этого алгоритм поиска в ширину запускается внутри множества вершин с низкой степенью. Алгоритм обхода проходит не по всем вершинам в графе, а лишь по вершинам внутри множеств, что позволяет быстрее найти центральные вершины, а кроме этого радиус графа.

\subsection{Алгоритмы, использующие матричное умножение}
В работе \cite{Seidel} приводится алгоритм, который использует в своей основе матричное представление графов.
Данный алгоритм оперирует в своей 
работе матрицами и самыми ресурсоемкими задачами в этом алгоритме являются процессы матричного перемножения, поэтому целиком и полностью ассимптотика этого подхода равна времени выполнения матричного умножения. Тривиальный алгоритм имеет ассимптотику $O(n^3)$, но при этом существует алгоритм быстрого матричного умножения \cite{Strassen1969}, способный решить 
эту задачу за время $O(n^{2.81})$.

\subsection{Генетические алгоритмы}
Под генетическими алгоритмами принято 
подразумевать вероятностно"=эвристические алгоритмы, которые применяются для решения задач оптимизации.
Сфера применения генетических алгоритмов достаточно широка, с одной стороны данные алгоритмы могут быть применены
при решении задач оптимизации, в которых недостаточно накопленных математических и алгоритмических знаний ввиду уникальности 
задачи или ее мало изученности. Кроме этого генетические алгоритмы могут быть применены при решении задач, для которых не 
существует эффективных алгоритмов решения "--- задачи из NP"=класса, а также подобные алгоритмы могут найти применение при 
попытках уменьшить временные затраты на решение хорошо изученной задачи.

В основе любого генетического 
алгоритма лежит моделирование 
эволюционного развития живых 
организмов за счет таких факторов, 
как естественный отбор, мутация и 
скрещивание.
Процесс скрещивания или кроссинговера 
впервые начал изучался в XIX веке 
ученым"=ботаником Г. Менделем.
В результате его исследований было 
установлено, что в набор генов живых 
организмов передаются гены его 
родителей причем в скомбинированном 
виде. Этот факт во многом объясняет с 
одной стороны все многообразие живых 
существ, а с другой явление передачи 
полезных свойств через поколения.

В дальнейшем с развитием науки были 
сделаны ряд открытий, связанных с 
таким явлением, как мутация генов.
Под мутацией понимается изменение 
генетических участков организма.
Чаще всего эти изменения происходят 
под воздействием внешних факторов или 
внутренних. Такие мутации чаще всего 
приводят к негативным последствиям, 
но вместе с там у живого организма 
появляется небольшая возможность 
получить новые внешние свойства, 
которые будут выгодно выделять его 
среди других организмов и переведут 
на новый виток эволюции.

В роли явления, которое 
отвечает за селекцию и выявление 
какие особи являются наиболее 
приспособленными к окружающей 
действительности, выступает 
естественный отбор. Отмеченный в работах Ч. Дарвина как один из ключевых процессов, который обеспечивает эволюционное 
развитие, естественный отбор сохраняет организмы с наиболее высоким уровнем приспособленности к окружающей среде и удаляет
особи из популяции, которые недостаточно хорошо приспособлены.

При рассмотрении природы, которая окружает организм, как некоторой сложно организованной системы легко заметить, что 
в процессе эволюции живые существа под воздействием описанных факторов способны с легкостью решать некоторую 
оптимизационную задачу, находя в окружающих условиях оптимальные положения и состояния. В связи с этим была предложена идея 
генетических алгоритмов "--- смоделировать описанные три процесса и на их основе запустить оптимизационный поиск.

Каждый генетический алгоритм \cite{HOLLAND, PANCHENCO} представляет собой итерационное применение операторов мутации, скрещивания и естественного 
отбора. При этом все эти операторы применяются к основной единице эволюции "--- популяции. В ходе такого итерационного 
применения этих операторов популяция должна найти некоторое оптимальное решение, при этом отнюдь не гарантируется, что это 
решение будет верным или же найденный оптимум будет являться глобальным. 

\subsubsection{Представление решения и начальная популяция}
Первым этапом в реализации генетического алгоритма является выбор способа кодирования решения. 
Закодированные возможные решения будут представлять собой особи в популяции.
Способ должен быть выбран таким образом, чтобы у операторов мутации и скрещивания была возможность с легкостью изменять 
каждую особь. Чаще всего при поиске оптимума некоторой вещественной функции каждая особь "--- это набор битов, которые 
кодируют вещественное число. Но данный подход не всегда может быть применен, поэтому способ кодирования решения выбирается 
чаще всего из постановки решаемой задачи.
Одним из параметров генетического алгоритма является размер популяции $N$.

\subsubsection{Оператор скрещивания}
Данный оператор занимается выбором особей для скрещивания и самим процессом скрещивания.
Задача этого оператора скомбинировать гены двух особей и создать на их основе новую особь для перехода в следующее поколение.
При этом процесс скрещивания происходит не всегда, а с вероятностью заданной в виде параметра $p_c$.

\subsubsection{Оператор мутации}
Оператор просматривает каждую особь в популяции и некоторым образом ее изменяет, при этом работает так же с некоторой 
вероятностью заданной через параметр $p_m$.

\subsubsection{Оператор естественного отбора}
При естественном отборе важна функция для оценки приспособленности каждой особи в популяции.
Чаще всего в качестве такой функции выступает функция, оптимальное значение которой ищется. 
Для начала оператор вычисляет приспособленность каждого организма в популяции, после чего формируется для каждой особи 
вероятность ее попадания в следующее поколение. Эта вероятность тем выше, чем  наиболее оптимальное решение 
представляет собой рассматриваемый элемент.
Выбор элементов популяции осуществляется при помощи так называемого колеса рулетки "--- каждой особи ставится в соответствие 
сектор в зависимости от уровня вероятности, после чего происходит генерация псевдослучайного числа, и в зависимости от того 
в какой сектор попало число, тот элемент и переходит в следующее поколение. Очевидно, что в следующем поколении окажется большинство 
особей с высоким уровнем приспособленности.

Среди недостатков, которыми обладает данный подход, можно выделить неуниверсальность генетических алгоритмов. Каждая задача 
требует уникальной разработки и адаптации всех описанных этапов под решаемую задачу. Кроме этого успешность работы алгоритма 
зависит от значений параметров $p_c$, $p_m$ и $N$.

Таким образом основными вопросами, которые стоят перед разработчиком, является реализация процессов скрещивания, мутации, 
естественного отбора и выбор критерия остановки алгоритма. Кроме этого необходимо исследовать параметры $p_c$, $p_m$ и $N$, 
которые существенным образом влияют на работу генетического алгоритма. 

Генетические алгоритмы также применялись для поиска центральных вершин. Например, в работе \cite{GA_N4N}, приводится генетический алгоритм, позволяющий решать различного рода задачи из теории графов. 

В основе построения данного алгоритма лежат классические этапы генетического подхода, при этом решение кодируется набором вершин, заданной мощности. В этой же работе рассматривается применение генетического алгоритма для решения целого ряда задач, одна из которых проблема нахождения $k$"=центральных вершин, которая заключается в том, что необходимо найти ровно $k$ центральных вершин, сумма эксцентриситетов которых была бы минимальна. Несложно заметить, что задача будет совпадать с проблемой поиска центральной вершины, если в качестве $k$ выбрать 1. 

В описываемом алгоритме оператор скрещивания имеет следующую реализацию. Рассматриваются две особи (два множества), которые должны перейти в следующее поколение. Далее находится разность второго множества с первым, которая называется первым вектором обмена, также находится разность первого со вторым, которая называется вторым вектором обмена, после чего генерируется случайная позиция, относительно которой будет производится скрещивание. После проделанных операций происходит обмен элементами относительно найденной позиции каждого множества с соответствующим ему вектором обмена. За счет такого подхода на каждой итерации алгоритма в множестве, описывающем конкретную особь, не существует повторяющихся вершин, при этом размер этого множества остается неизменным.

В качестве оператора мутации используется следующий подход: для каждой вершины находится набор ее соседей, после чего из этого множества случайным образом выбирается 4 вершины, которых нет в множестве особи. Для каждой из четырех вершин находится ее эксцентриситет, 
после чего с вероятностью заданной для оператора мутации вершина"=сосед заменяет вершину в популяции. Данный подход был назван авторами N4N эвристикой, поэтому далее данный алгоритм будет называться <<N4N алгоритм>>. В естественном отборе в качестве целевой функции ставиться значение эксцентриситета вершины. 

Данный подход в реализации генетического алгоритма позволяет решать не только задачу поиска центральных вершин, но и еще ряд проблем связанных с теорией графов, однако ввиду общности способа представления решения и реализации оператора скрещивания, может иметь свои недостатки, которые могут проявиться в конкретной задаче.

\section{Разработка генетического алгоритма и его исследование}
Так как генетические алгоритмы являются методом решения оптимизационных задач, в задаче поиска центральных вершин необходимо 
выделить функцию, оптимальное значение которой требуется оптимизировать.
Легко заметить, что если рассмотреть граф $G = (V, E)$ и функцию на нем $F: V \mapsto \mathbb{R}$, которая определяет 
эксцентриситет каждой вершины, то получается, что для нахождения центральных вершин необходимо найти минимальное значение 
этой функции с помощью генетического алгоритма. 

Генетический алгоритм должен содержать адаптированные под решаемую задачу этапы 
скрещивания, мутации и естественного отбора.
Основная идея алгоритма может быть выражена следующим образом. 
Пусть существует некоторое абстрактное или реальное изображение графа,
причем в центре этого изображения находятся центральные вершины графа.
Тогда, если популяция генетического алгоритма представляет собой 
набор вершин, то этот набор может быть представлен в виде некоторого шара, внутри которого 
находится центральные вершины графа (см. рисунок \ref{pic1}).


Из этой идеи следует, что для того чтобы найти центральные вершины необходимо, чтобы эта абстрактная сфера сжималась к 
центру. Именно этот смысл заложен в работу оператора скрещивания. В добавок к этому алгоритм должен сжимать эту <<сферу>> к 
глобальному центру, не сбиваясь в локальные оптимальные значение, за это отвечает оператор мутации. Естественный отбор 
соответственно занимается выбором вершин с оптимальными эксцентриситетами. Если реализовать все эти три шага и запустить их, 
то в идеальном варианте после нескольких итераций популяция алгоритма должна находиться в состоянии, которое показано на 
рисунке \ref{pic2}.

\subsection{Старт алгоритма}
Для начала алгоритма необходимо сгенерировать начальную популяцию с размером $N$, которая и будет эволюционировать.
В предлагаемом алгоритме в качестве начальной популяции генерируется случайный набор уникальных вершин, причем вероятность 
попадания в начальную популяцию одинакова для всех вершин.

\subsection{Естественный отбор}
Как уже говорилось ранее, естественный отбор занимается выбором оптимальных вершин для продолжения работы алгоритма.
Для каждой вершины находится ее эксцентриситет при помощи обхода в ширину (см. рисунок \ref{pic3}), после чего методом колеса рулетки, при этом приоритет отдается вершинам с меньшим эксцентриситетом.

\subsection{Этап скрещивания}
Основной смысл разработанного алгоритма кроется в операторе скрещивания. Так как необходимо, чтобы <<сфера>>, описываемая 
популяцией, с каждой итерацией сжималась, то скрещивание реализовано следующим образом: в качестве родителей выбираются две 
вершины из популяции, после чего между ними находится кротчайший путь, после чего из этого пути выбирается одна вершина в качестве потомка (см. рисунок \ref{pic4}). Именно такая реализация данного этапа позволяет алгоритму сходиться к центральным вершинам. При этом процесс скрещивания происходит с вероятностью $p_c$.

\subsection{Этап мутации}
Для того, чтобы у алгоритма была возможность выхода из локальных оптимальных значений существует этап мутации, который имеет 
следующую реализацию: перебираются все вершины в популяции и для каждой вершины находятся ее соседи "--- вершины смежные с ней, после чего с вероятностью $p_m$ вершина заменяется на одного из своих соседей (см. рисунок \ref{pic5})

Все описанные этапы представлены в виде псевдокода \ref{alg-1}.



При работе каждого из этапов в оперативной памяти поддерживается матрица $n \times n$, где $n$ "--- число вершин в графе, 
хранящая найденные расстояния между вершинами, а кроме этого такая же матрица, внутри которой лежат кротчайшие пути между 
вершинами. Такое поддержание матриц позволяет многократно не пересчитывать расстояния между вершинами, если этого требует 
алгоритм. 
Визуальную работу алгоритма можно увидеть на рисунке \ref{pic6}.


\subsection{Исследование алгоритма}
В качестве языка программирования для исследования алгоритма был выбран язык программирования C++.
Кроме этого в качестве среды разработки, в которой производилась реализация алгоритма, была выбрана \\
\verb|Visual Studio 2017|, а вычислительная машина, на которой были выполнены все испытания обладает оперативной памятью с 
размером \verb|6.0 GB| и процессором \verb|AMD A8-7410| с частотой \verb|2.20 GHz|.

Кроме этого для запусков тестов алгоритма необходимы наборы графов с разными свойствами. Для создания графов использовалась 
\verb|Python| библиотека \verb|NetworkX|, которая предоставляет возможности для генерации данных на основе различных моделей 
случайных графов.

За основную работу алгоритма отвечает класс \verb|GeneticAlgorithm|, в котором реализованы основные методы генетического алгоритма:
\begin{itemize}
	\item \verb|makeSelection| "--- метод, отвечающий за реализацию естественного отбора,
	\item \verb|crossing| "--- метод, отвечающий за реализацию скрещивания,
	\item \verb|mutation| "--- метод, отвечающий за реализацию мутации,
	\item \verb|getBestResult| "--- метод, который запускает генетический алгоритм, измеряет время его работы и возвращает найденные оптимальные 
	значения.
\end{itemize}
Полный код класса можно увидеть в приложении \ref{app:ga}.


При всем этом для хранения найденных путей и кротчайших расстояний реализован класс \verb|Graph|, внутри которого находятся методы, отвечающие за 
запуск обхода в ширину и получение найденных расстояний и кротчайших путей. Основные методы этого класса:
\begin{itemize}
	\item \verb|bfsFromVertex(int x)| "--- метод, запускающий алгоритм обхода в ширину из вершины, переданной в качестве параметра
	\item \verb|getPath(int x, int y)| "--- метод, возвращающий расстояние между двумя вершинами в графе,
	\item \verb|getEccentricity(int x)| "--- метод, возвращающий эксцентриситет вершины,
	\item \verb|getNeighbour(int x)| "--- метод, получающий соседей заданной вершины.
\end{itemize}

Также с кодом этого класса можно ознакомиться в приложении \ref{app:graphWork}.
Сгенерированные графы, на которых тестируется алгоритм, хранятся в текстовых файлах.
В текстовых фалах находятся ребра графа, которые записаны на каждой строке,
при этом на первой строке записано число вершин в графе и число ребер.
Для того, чтобы прочитать текстовый граф была реализована следующая функция чтения:


методу на вход передаются такие параметры, как имя файла, ссылка на переменную для числа вершин в графе, а так же ссылка на число ребер в графе.
Метод возвращает вектор пар, где каждая пара описывает ребро графа. 

За связывание файлов с графами с их найденными ранее радиусами отвечает класс \verb|Repository|, внутри которого закодированы имена файлов и 
дополнительная информация об этих файлах.
Для того, чтобы получить граф существует публичный метод \verb|getGraph|, который принимает строку, описывающую какой тип графа запрошен, после 
чего открывается файл, граф считывается и возвращается из  метода. Со всеми этими действиями можно ознакомиться в приложении \ref{app:graphWork}.

Для того, чтобы данные, возвращаемые из методов или передаваемые в качестве параметров были соединены в единую структуру были созданы следующие сущности. 
Класс \verb|GraphDescription|: 


используется для хранения графа в нем содержаться поля, отвечающие за размеры графа и его радиус.

Кроме этого для того, чтобы хранить результаты вычислительных экспериментов существует класс \verb|GaTestResult|:

В объектах данного класса хранятся значения вычисленной функции, например времени, а кроме этого значения параметров, на которых были получены 
эти результаты.

Для того, чтобы облегчить работу с запусками алгоритма с разными параметрами и легко проводить различного рода тесты создан класс \verb|Experiment|. 
Данный класс включает реализацию всех необходимых методов для исследования параметров алгоритма:
\begin{itemize}
	\item \verb|calculateTimeErrorValue| "--- private метод, который запускает генетический алгоритм,
	и возвращает среднее время работы и процент ошибок,
	\item \verb|testWithChangebleProb| "--- метод который принимает размер популяции и фиксированный параметр, а так же флаг показывающий какой из параметров будет изменяться для исследования,
	\item \verb|oneDimentionFixedGATest| "--- запуск теста с изменяющимся параметром,
	\item \verb|simpleTimeErrorTest| "--- простой запуск алгоритма, с переданными ему вероятностью скрещивания, мутации и размеров популяции,
	\item \verb|simpleNANTest| "--- запуск алгоритма N4N,
	\item \verb|pmpcGaTest| "--- метод для запуска теста с перебором всех значений $p_c$ и $p_m$, 
	\item \verb|nGATest| "--- метод для запуска теста с перебором параметра $N$.
\end{itemize}
Полный код класса представлен в приложении \ref{app:experiment}.



\subsection{Модели случайных графов}
Для исследования алгоритма применялись следующие модели случайных графов: модель Эрдеша"=Реньи, модель Барабаши"=Альберт и 
модель случайного геометрического графа. Все они в той или иной степени частично описывают реальные графы.

\subsubsection{Модель случайного графа Эрдеша"=Реньи}
Данная модель представлена в работе \cite{ER} и является одной из самых простых и базовых моделей случайного графа. Изначально для создания графа задаются 
два параметра $n$ "--- число вершин в графе и $p$ "--- вероятность проведения ребра. 
Далее для построения графа рассматриваются все пары вершин, и между ними проводится неориентированное ребро с вероятностью $p$. В данной модели ввиду ее 
простоты формулировки довольно легко выводятся формулы, зависящие от параметра $p$ и $n$, которые описывают основные характеристики графов, такие как 
связность, размер максимальной клики, распределение степени вершин и т.д. Поэтому, если удается установить, что граф в рассматриваемой задаче близок по 
свойствам с графом Эрдеша"=Реньи, то можно без труда получить много информации об изучаемом графе.

\subsubsection{Модель случайного графа Барабаши"=Альберт}
Данная модель случайного графа была предложена в работе \cite{BA}. На данный момент описанная модель позволяет создавать так называемые безмасштабные сети 
"--- графы, в которых распределение степеней подчиняется степенному закону. Исследования данного подхода показали, что графовые модели, которые описывают 
взаимосвязи внутри различных самоорганизующихся систем, совпадают с моделью Барабаши"=Альберт. К таким сетям относятся ряд графов социальных сетей, сеть 
Интернет, ряд графовых моделей в природных сетях. 

В ходе построения случайного графа поддерживаются два основных принципа, которые главным образом характеризуют безмасштабные сети. Первый из них принцип расширения сети, второй "--- предпочтительное прикрепление. Первый принцип описывается тем фактом, что в существующую сеть могут постоянно добавляться новые узлы, при этом не нарушая его свойств из"=за второго принципа. Принцип предпочтительного прикрепления заключается в том, что добавляемый узел случайным образом прикрепляется ребрами к вершинам, которые уже существуют в графе, при этом предпочтение отдается вершинам с большей степенью, формально вероятность проведения ребра к $i$"=му узлу описывается следующий формулой:
\[
	p_i = \frac{k_i}{\sum_j k_j},
\] 
где $k$ "--- степень узла, $j$ пробегает все вершины в графе. 

Для создания графа задаются два параметра $n$ "--- число вершин в создаваемом графе, и $m$ "--- число ребер, которые проводятся из каждой новой добавляемой вершины в граф. Алгоритм создания достаточно прост, в качестве начального графа берется связный граф с числом вершин большим или равным $m$, после чего добавляются новые вершины до необходимого количества, при этом каждая новая вершина соединяется с $m$ вершинами случайным образом с вероятностным распределением, описанным формулой выше.

\subsubsection{Геометрический случайный граф}
Данная модель случайного графа \cite{GEOM} описывает основные свойства, которые возникают в графовых моделях компьютерных сетей и сетей, имеющих явную географическую интерпретацию. Для построения графа выбирается размерность пространства, в котором будет создаваться граф, наиболее часто выбирается двумерное пространство, на котором случайным образом генерируется набор геометрических точек равных по количеству числу узлов в создаваемом графе, после чего для каждой пары точек рассчитывается евклидово расстояние между ними и проводится ребро в том случае, если расстояние меньше параметра $r$, который задается заранее.

Данная модель случайного графа имеет свои отличительные характеристики, которые не совпадают с моделями Эрдеша"=Реньи и Барабаши"=Альберт.

\subsection{Результаты вычислительных экспериментов}
Для выявления сильных и слабых сторон предложенного алгоритма его сравнение проводилось с рядом точных алгоритмов, а также с алгоритмом <<N4N>>. В качестве тестовых графов были выбраны графовые модели описанные ранее. Для модели Эрдеша"=Реньи в качестве параметра $p$ было выбрано значение 5\%, для модели Барабаши"=Альберт $m = 2$, а для геометрического случайного графа $r = 0.1$. 

Для сравнения по временным результатам были реализованы тривиальный алгоритм и алгоритм с улучшенной асимптотикой. Эти алгоритмы и генетический алгоритм описанный в данной работе запускались на трех моделях случайных графов, с количеством вершин 500, 1000, 1500, 2000, 2500, 5000. Исходя из практических экспериментов в качестве размера популяции выбрано значение 50, для оператора скрещивания 0.7, для оператора мутации 0.1, кроме этого число итераций ограничено числом 20. Результаты временных измерений приведены на графиках \ref{pic6}. Из полученных результатов видно, что созданный генетический алгоритм дает выигрыш по времени в несколько раз по сравнению с точными алгоритмами. 


Также так как эвристический алгоритм не гарантирует получение точного ответа, а допускает некий процент ошибки, то для изучения точности алгоритма были 
проведены тесты позволяющие выявить процент неправильных ответов. Для этого алгоритм запускался на все тех же графах, при этом так как размерности графа, 
позволяют за приемлемые временные затраты с помощью точного алгоритма найти центральные вершины, то зная эту информацию можно говорить о проценте 
неправильных ответов. Для сравнения брался алгоритм <<N4N>>, после чего оба алгоритма запускались 100 раз, что позволило подсчитать процент ошибки. 
Результаты вычислительных экспериментов приведены в таблицах \ref{tab1}, \ref{tab2} и \ref{tab3}. 


Из полученных результатов видно, что созданный алгоритм не уступает существующему эвристическому алгоритму. Предложенный алгоритм превосходит второй 
генетический алгоритм в несколько раз. Это во многом объясняется тем, что в алгоритме <<N4N>> используется множество для описания одной особи в популяции, 
а также при процессе мутации для вершин, которые претендуют на изменение особи, находится эксцентриситет, всех этих процессов нет в созданном алгоритме, 
поэтому его время работы меньше.
При этом видно, что алгоритм <<N4N>> на некоторых моделях случайных графов имеет меньший процент ошибки по сравнению с предложенным алгоритмом, однако 
этот процент нивелируется с увеличением размерности графа.

\subsection{Исследование параметров генетического алгоритма}
В приведенных ранее результатах в качестве значений параметров генетического алгоритма были выбраны значения $N = 50$, $p_c 
= 0.7$ и $p_m = 0.1$. Однако эти значения выбирались в качестве тестовых для того, чтобы проверить жизнеспособность идей, 
заложенных в алгоритм.
При этом эти параметры ключевым образом влияют как на точность алгоритма, так и на время его выполнения.
В связи с этим был также проведен еще ряд экспериментов, в которых исследовались эти параметры.
Для начала были произведены запуски, в которых перебирались значения для $p_m$ и $p_c$ от 0 до 1. Для каждого значения этих параметров измерялось время работы алгоритма и его процент ошибок. При этом значение размера популяции было равно 20. 
Результаты этих экспериментов представлены в таблицах \ref{tab4} и \ref{tab5}.


Из этих таблиц видно, что время работы алгоритма растет по мере увеличения как параметра $p_m$, так и параметра $p_c$.
Вместе с тем видно, что и процент неверных ответов падает по мере увеличения тех же параметров.
Очевидно, что необходимо найти некоторые оптимальные значения для того, чтобы процент неверных ответов был невелик и 
одновременно с этим необходимо, чтобы время работы было минимальным. Для того чтобы соединить воедино два этих фактора была введена функция:

\begin{equation}
F(pm, pc) = \alpha\,time(pm, pc) + \beta\,error(pm, pc),
\end{equation} 
которая учитывает время работы и процент ошибок, причем параметр $\alpha$ отвечает за уровень значимости временных затрат, а параметр $\beta$ отвечает за значимость процента ошибок.
Если подставить все полученные данные в эту функцию, то получится результат, который представлен в таблице \ref{tab6}.

Из этой таблицы видно, что оптимальных значений функция $F$ достигает в центре таблицы. 
Например, в эксперименте, который описывает таблица \ref{tab6} оптимальное значение достигается при $p_m = 0.4$ и $p_c = 0.4$
При фиксированных значениях параметра $p_m = 0.4$ и $p_m = 0.6$ были построены графики \ref{pic8} и \ref{pic9}, на которых отражено нормированное 
время работы и нормированный процент ошибки. Из этих графиков видно, что при увеличении параметра $p_m$ значительно увеличивается и время работы 
алгоритма и уменьшается процент неверных ответов.


Кроме этого важным параметром для генетического алгоритма является размер популяции $N$ и в связи с этим был проведен эксперимент,
в котором измерялся процент ошибок и время работы при фиксированных значениях $p_m = 0.4$ и $p_c = 0.4$ \ref{pic10} и \ref{pic11}. 


На этих графиках видно, что время работы алгоритма имеет практически линейную зависимость, а также процент ошибок экспоненциально уменьшается 
в зависимости от числа $N$ и после значения 30, становится близким к нулю.

Очевидно, что в зависимости от того каким образом будут изменяться размеры графов, будет зависеть и набор оптимальных значений параметров.
В связи с этим были проведены вычислительные эксперименты, на других графе другой размерности. Результаты этих экспериментов представлены в
таблицах \ref{tab7}, \ref{tab8}, \ref{tab9}.


Из этих таблиц видно, что тенденция роста времени работы сверху вниз и слева направо сохранена, что можно сказать и про такую же тенденцию к 
снижению ошибок. Вместе с тем из таблицы \ref{tab9} видно, что оптимальные значения параметров равны $p_m = 0.2$ и $p_c = 0.3$. 
На этом же графе был произведен замер времени работы и процента ошибок в зависимости от размеров популяции. Результаты этих измерений 
представлены на графиках \ref{pic12} и \ref{pic13}.


Из этих графиков точно так же видно, что время работы растет линейно, а процент неверных ответов падает экспоненциально.
Кроме этого для некоторых значений $N$ было найдено минимальное значение функции $F$ при различных значениях $\alpha$ и 
$\beta$ (см. рисунки \ref{pic14} и \ref{pic15}).


Как видно из графиков, при больших значениях параметра $\alpha$, отражающего значимость временных затрат значения функции 
$F$ возрастают с увеличением размеров популяции, а при равных значениях $\alpha$ и $\beta$ такого большого изменения функции не происходит.

\section{Описание приложения, созданного для работы с генетическим алгоритмом}
Кроме этого для работы с генетическим алгоритмом создано отдельное приложение.
Приложение представляет собой веб"=сайт, через который предоставляется возможность для работы с генетическим алгоритмом.
С одной стороны у пользователя есть доступ к исследованию алгоритма и его запуску с различными параметрами, а с другой 
пользователь может заняться исследованием собственного графа и запустить алгоритм на нем.

При входе в приложение пользователь попадает на главную страницу см. рисунок \ref{fig:f2}.

На главной странице пользователь видит небольшое описание алгоритма и, главным образом, навигационную панель, которая 
находится 
наверху страницы. На этой навигационной панели находятся ссылки на страницу с формой для поиска центральных вершин, страницу с 
формой для запуска алгоритма с различными параметрами и на различных графах, а так же ссылка для входа зарегистрированных 
пользователей. 

После перехода на страницу входа (см. рисунок \ref{fig:f3}) пользователь может ввести свои логин и пароль и, после успешной 
аутентификации он будет перенаправлен на главную страницу, при этом в навигационной панели появятся ссылки на страницу добавления новых пользователей, новых графов, а так же будет отображаться его логин (см. рисунок \ref{fig:f4})


При переходе на страницу, с которой возможно загрузить граф для поиска радиуса, пользователю показывается форма, через которую 
загружается граф (см. рисунок \ref{fig:f5}).

Похожая страница показывается пользователю при загрузке нового графа на сервер (см. рисунок \ref{fig:f8}).

Если пользователь не загрузит граф или загрузит файл в неверном формате, то получит страницу с сообщением об ошибке (см. 
рисунок \ref{fig:f6}, \ref{fig:f7}).

При верно загруженном файле пользователю открывается страница, на которой отображаются результаты запуска алгоритма: время 
его работы, полученный радиус графа и возможные центральные вершины (см. рисунок \ref{fig:f9}).
Кроме этого у пользователя есть возможность запускать генетический алгоритм с различными параметрами (см. рисунок 
\ref{fig:f10}).

На форме находятся несколько ползунков, через которые можно выставить основные параметры генетического алгоритма, а также 
там находится выпадающий список, в котором выбирается один из сохраненных графов. 
После того как пользователь выбрал соответствующие параметры и отправил форму на сервер с выбранными параметрами, запускается 
алгоритм, причем несколько раз, для того, чтобы получить эмпирическую оценку времени работы и процента неверных ответов.
Именно эти результаты показываются на форме, которая открывается пользователю после работы алгоритма (см. рисунок 
\ref{fig:f11}).

Каждому зарегистрированному пользователю предоставляется возможность для добавления новых пользователей через 
соответствующую форму (см. рисунок \ref{fig:f12}). К данным, которые вводит пользователь, выдвигаются следующие требования: 
длина пароля и логина должна быть от 5 до 50 символов, и пользователь с таким же логином не должен уже существовать в базе 
данных. Если эти условия не будут выполнены, пользователь получит соответствующее сообщение об ошибке (см. рисунок 
\ref{fig:f13}).

\subsection{Описание технологий и архитектуры приложения}
В качестве языка программирования для создания проекта был выбран объектно"=ориентированный язык C\#.
Вместе с тем, для создания клиент"=серверного приложения был использован фреймворк \verb|ASP.NET MVC 5| \cite{ADAM_FRIMAN, MVC}, который 
позволяет создавать веб"=приложения с использованием архитектуры \verb|MVC|. Кроме этого в качестве системы 
объектно"=реляционного 
отображения используется технология \verb|Entity Framework 6| \cite{EF6}. При этом приложение разделено на три слоя 
абстракции "--- уровень доступа к данным, уровень бизнес"=логики и уровень визуального представления. 

\subsection{Структура базы данных}
Для создания базы данных используется технология \verb|Entity Framework 6|, который позволяет использовать подход 
\verb|Code-first|, согласно которому были созданы классы \verb|Graph|, \verb|GraphInfo|, \verb|Edge|, \verb|User|, 
описывающие модели данных:

После чего фреймворк на основании созданных моделей создал структуру базы данных и связи между таблицами.

Для хранения графов в базе данных были созданы следующие таблицы: \verb|Graphs| и \verb|Edges|. 
Таблица \verb|Graphs| содержит следующие поля:
\begin{itemize}
    \item поле \verb|Id| (типа данных \verb|INT|) "--- уникальный идентификатор, внутренний ключ,
    \item поле \verb|N| (типа данных \verb|INT|) "--- количество вершин в графе, 
    \item поле \verb|M| (типа данных \verb|INT|) "--- количество ребер в графе,
    \item поле \verb|Name| (типа данных \verb|NVARCHAR|) "--- название графа,
    \item поле \verb|R| (типа данных \verb|INT|) "--- радиус графа.
\end{itemize}
Таблица \verb|Edges| состоит из следующих полей: 
\begin{itemize}
    \item поле \verb|Id| (типа данных \verb|INT|) "--- уникальный идентификатор, внутренний ключ,
    \item поле \verb|V1| (типа данных \verb|INT|) "--- одна из вершин, которые соединяет ребро, 
    \item поле \verb|V1| (типа данных \verb|INT|) "--- вторая из вершин, которые соединяет ребро,
    \item поле \verb|Graph_Id| (типа данных \verb|INT|) "--- \verb|Id| графа, которому принадлежит ребро, внешний ключ.
\end{itemize}
Кроме этого для хранения зарегистрированных пользователей существует таблица \verb|Users|:
\begin{itemize}
    \item поле \verb|Id| (типа данных \verb|INT|) "--- уникальный идентификатор, внутренний ключ,
    \item поле \verb|Login| (типа данных \verb|NVARCHAR|) "--- логин пользователя,
    \item поле \verb|Password| (типа данных \verb|VARBINARY|) "--- захешированный пароль пользователя.
\end{itemize}


\subsection{Уровень доступа к данным}
Для гибкой и стандартизированной работы с базой данных был создан ряд интерфейсов,
в которые были вынесены основные методы для доступа к данным и их изменениям.
Классы, реализующие эти интерфейсы представляют собой уровень доступа к данным, при этом 
использование интерфейсов позволяет с легкостью изменять реализацию этих классов, а также упрощает 
процесс тестирования.

Далее приводится код основных интерфейсов, которые используются при работе с данными:

Вместе с тем для использования технологии \verb|Entity Framework| созданы классы \verb|GraphContext| и \verb|UserContext|, 
которые наследуются от класса \verb|System.Data.Entity.DbContext|, что позволяет получить возможность для легкого
доступа к базе данных без написания SQL запросов. Классы \\ \verb|GraphContext| и \verb|UserContext| содержат в себе поля типа
\verb|DbSet<Graph>| и \verb|DbSet<User>|, через которые происходит добавление, чтение или изменение данных в базе данных.
Кроме этого в этих классах описан статический конструктор, внутри которого указан способ начальной инициализации базы данных, 
за счет классов \verb|UserContextInitializer| и \verb|GraphContextInitializer|. Эти классы наследуются от класса 
\verb|CreateDatabaseIfNotExists|, что позволяет фреймворку выполнить начальное заполнение данными, если база данных еще не 
существует, за счет кода, который описан в переопределенном методе \verb|Seed|. 
 Внутри метода, описанного в классе \verb|GraphContextInitializer|, происходит чтение нескольких созданных графов из текстовых файлов, в методе с этим же именем в классе 
\verb|UserContextInitializer| добавляется пользователь с логином \verb|admin| и паролем \verb|admin|. Полный код представлен в приложении \ref{app:dal}.
 
\subsection{Уровень бизнес-логики}
Уровень бизнес-логики представляет собой похожую структуру, как и уровень доступа данных "--- так же 
созданы ряд интерфейсов и классы, которые их реализуют. 
При этом многие из этих интерфейсов похожи на те, которые описаны в уровне доступа к данным, однако 
именно на этом уровне происходит запуск генетического алгоритма с различными параметрами и    
анализ загруженных графов.
С определением интерфейсов и классов, реализующих бизнес-логику приложения можно ознакомиться в приложении \ref{app:bl}.
Классы \verb|GraphBL| и \verb|UserBL|, реализуют интерфейсы \verb|IGraphBL| и \verb|IUserBL|. Они содержат ссылки на объекты, 
реализующие интерфейсы \verb|IGraphDao| и \verb|IUserDao|. 
При добавлении нового пользователя происходит проверка на существование записи с таким же логином, а кроме этого происходит 
хеширование пароля. 

При добавлении нового графа в базу данных в классе, который отвечает за работу с моделью графа, происходит проверка графа на связность и проверка на размеры графа. При неудачном прохождении проверки выбрасывается исключение, которое отлавливается на уровне представления.

Кроме этого для работы с генетическим алгоритмом создан интерфейс \verb|IAlgorithm|:

Интерфейс определяет набор методов, в которых будет реализована логика для работы с генетическим алгоритмом.
Вместе с тем класс \verb|Algorithm| реализует данный интерфейс и в нем содержится вся логика работы с алгоритмом "--- получение 
результатов поиска центральных вершин, замеры времени работы и процента неверно найденных решений.
 
Результаты измерений возвращаются из методов при помощи классов \verb|FindingVertexResponse| и \verb|ResearchAlgorithmResponse|:


Полный код классов уровня бизнес"=логики можно увидеть в приложении \ref{app:bl}.

\subsection{Уровень представления}
Так как проект представляет собой веб"=приложение, то уровень, отвечающий за пользовательский интерфейс реализован при помощи 
технологии \verb|ASP .NET MVC 5|. В связи с чем весь код этого уровня разделен на:
\begin{itemize}
    \item контроллеры, которые отвечают на HTTP запросы клиента с помощью представлений,
    \item представления, которые написаны с использованием технологии Razor, позволяющей внедрять серверный C\# код,
		\item модели данных, внутри которых происходит передача данных от клиента серверу и обратно.
\end{itemize}

\subsubsection{Контроллеры}
Для взаимодействия с клиентской частью приложения и обработки пользовательских данных было создано несколько
контроллеров: \verb|HomeController|, \verb|GraphController|, \verb|LoginController|, \verb|ResearchController|.

Класс \verb|HomeController| содержит один метод \verb|Index|, который отвечает на GET"=запрос и возвращает домашнюю страницу.

Класс \verb|GraphController| включает в себя методы, определяющие URL"=адреса при взаимодействии с которыми клиентской части 
приложения предоставляется возможность запускать генетический алгоритм для поиска центральных вершин или добавлять новый граф в 
базу данных. В целом данный контроллер ответственен за обработку следующих запросов:
\begin{itemize}
	\item \verb|/Graph| "--- обрабатывает GET"=запрос и возвращает загрузочную страницу для поиска центральных вершин, 
	\item \verb|/Graph/FindCentralVertex| "--- обрабатывает POST"=запрос, в котором передается файл с графом, после чего запускается 
	генетический алгоритм. В качестве результата возвращается страница с сообщением об ошибке, которая могла произойти при 
	обработке запроса из"=за неверного формата данных в файле с графом, или слишком большого размера загружаемого графа.  
	При успешном запуске возвращает страницу с результатами работы "--- радиус графа и возможные центральные вершины, 
	\item \verb|/Graph/Add| "--- обрабатывает GET"=запрос, который возвращает форму для загрузки графа в базу данных,
	\item \verb|/Graph/Add| "--- обрабатывает POST"=запрос, в котором пользователь предает на сервер для сохранения файл с графом и название 
	графа. При успешном добавлении перенаправляет пользователя на домашнюю страницу, при возможной ошибке "--- на страницу с 
	описанием ошибки.
\end{itemize}

Класс \verb|ResearchController| содержит методы, через которые пользователю предоставляется возможность запускать генетический 
алгоритм с различными параметрами ($p_c, p_m, N$), а также граф на котором будет тестироваться алгоритм.
Контроллер содержит следующие методы:
\begin{itemize}
	\item \verb|/Research/Index| "--- обрабатывает GET"=запрос и возвращает форму с выбором параметров для генетического 
	алгоритма, при этом в результат подгружаются описания графов, сохраненных в базе данных,
	\item \verb|/Research/ResearchAlgorithm| "--- обрабатывает POST"=запрос, в который передаются выбранные параметры алгоритма и выбранный граф.
\end{itemize}

В классе \verb|LoginController| определены методы, за счет которых происходит регистрация и аутентификация пользователей.
Пользователь, который вошел в систему получает возможность для добавления новых графов и добавление новых пользователей, залогиненному пользователю предоставляются права администратора.
В контроллере \verb|LoginController| реализованы следующие методы:
\begin{itemize}
	\item \verb|/Login/Index| "--- обрабатывает GET"=запрос и возвращает форму заполнения для входа в систему,
	\item \verb|/Research/SignIn| "--- обрабатывает POST"=запрос, в который передается логин и пароль. 
	В этом методе происходит валидация введенных данных, проверка принадлежности пароля введенному пользователю и при успешном 
	прохождении этих этапов, пользователю отправляется набор cookie"=данных, вследствие чего происходит аутентификация пользователя. 
	При неверном логине или пароле пользователю возвращается сообщение об ошибке, при успешном прохождении аутентификации "--- метод 
	возвращает переадресацию на домашнюю страницу,
	\item \verb|/Login/SignUp| "--- обрабатывает GET"=запрос и возвращает форму для регистрации нового пользователя,
	\item \verb|/Login/SignUp| "--- обрабатывает POST"=запрос и добавляет нового пользователя при успешном прохождении валидации 
	и отсутствии пользователя с таким же логином.
\end{itemize}

Полный код контроллеров можно увидеть в приложении \ref{app:controllers}.

\subsubsection{Модели данных и валидация}
Основными классами, с помощью объектов которых происходит передача данным в контроллеры, \verb|AddGraphRequest|, 
\verb|CreateUserRequest|, \\ \verb|LoginUserRequest|, 
\verb|ResearchRequest|, при этом результаты вычислений возвращаются из контроллеров в виде представлений, которые 
представляют собой HTML разметку с внедрением данных, переданных через классы \\ \verb|AlgorithmResultResponse|, 
\verb|FindingVertexResponse|, \\ \verb|ResearchAlgorithmResponse|. 

При этом очевидно, что при введенные пользовательские данные должны удовлетворять некоторым условиям.
Для того, чтобы передаваемые данные можно было проверить из любого участка кода для некоторых свойств
были использованы атрибуты валидации \cite{VALIDATIONS} \verb|Required|, \verb|Compare|, \verb|StringLength|:

При таком использовании атрибутов валидации проверить модель на соответствие выдвинутым требованиям можно при помощи следующего 
кода:

внутри любого из контроллеров, где \verb|ModelState| "--- свойство класса \verb|Controller|, которое инкапсулирует состояние 
модели, переданной в качестве параметра запроса. В случае неудачного прохождения валидации в свойство \verb|ModelState| при 
помощи метода \verb|AddModelError| добавляется сообщение об ошибке, которое затем будет вставлено в HTML разметку. 
Атрибут \verb|Requred| установлен для логина и пароля, вводимого пользователем, что гарантирует тот факт, что в базу данных не 
будет помещена запись с пустыми полями. В добавок к этому у свойства \verb|ConfirmPassword| установлен атрибут 
\verb|Compare|, 
который требует, чтобы свойство, отвечающее за хранение пароля, совпадало со свойством, отвечающим за хранение повтора пароля. 
Также используется атрибут \verb|StringLength|, в котором устанавливаются минимальная и максимальная длина логина и пароля.

\subsubsection{Аутентификация}
Как уже отмечалось ранее доступ к возможности добавлять графы в базу данных и добавлять туда же новых пользователей имеют 
доступ только пользователи, которые вошли в систему. В связи с этим в качестве технологии аутентификации в созданном приложении 
используется аутентификация с помощью форм \cite{FORMS_AUTH}. 
Для ее включения в файл \verb|Web.config| были добавлены следующие строки:

в которых указывается по какому адресу будет отправлен пользователь в случае, если он не имеет прав доступа к запрошенным 
ресурсам и время действия cookie"=файлов.
При успешном прохождении проверки на принадлежность пользователю введенного им пароля, при помощи следующей строки кода 
клиентская часть получает cookie"=файлы, которые затем будут присоединяться ко всем остальным запросам:

Для того, чтобы к определенным методам был доступ только авторизированным пользователям к каждому методу применяется атрибут 
\verb|Authorize|, который гарантирует проверку на доступность для пользователя этих методов.
При этом для пользователя вошедшего в систему несколько изменяется HTML разметка, что достигается при помощи 
использования свойства \verb|User.Identity.IsAuthenticated|.

\subsection{Хеширование паролей}
Очевидно, что хранение паролей пользователей в открытом виде 
представляет собой подход нарушающий основные требования к безопасности приложения. 
В связи с чем каждый пароль при регистрации пользователя хешируется и полученный хеш сохраняется в 
базе данных. Хеширование паролей происходит в классе \verb|Encryption| (см. приложение \ref{app:bl}), где определены публичные 
методы \verb|CreatePassword| и \verb|CheckPassword|. 
Создание хеша пароля происходит при помощи объекта класса \verb|Rfc2898DeriveBytes| \cite{Rfc2898DeriveBytes}:

В конструктор класса передается строка с паролем, <<соль>> "--- псевдослучайная последовательность байт, которая используется 
для повышения криптоустойчивости хеша и параметр, отвечающий за искусственную временную задержку, которая позволяет избежать 
попытки грубого перебора. 
В базу данных сохраняется полученный хеш и сгенерированная <<соль>>.
При проверке подлинности пароля из базы данных извлекается хеш c <<солью>>, после чего введенный пароль хешируется с сохраненной <<солью>> и результат сравнивается с тем, что было сохранено в базе данных.

\subsection{Внедрение зависимостей}
Ранее описывались независимые уровни, на которые разделено приложение, при этом гибкость и заменяемость каждого из уровней 
гарантируется существованием интерфейсов. Каждый из уровней содержит ссылки на объекты, которые реализуют тот или иной интерфейс, при 
этом эти объекты передаются в качестве параметров в конструкторы. Для того, чтобы гарантировать тот факт, что во все 
конструкторы будут переданы одни и те же реализации интерфейсов и избежать дублирования кода в созданном приложении 
используется IoC"=контейнер \verb|Ninject|, который связывает интерфейсы с объектами, которые их реализуют и предоставляет их 
при необходимости.
Связывание интерфейсов и реализации происходит в методе класса \verb|NinjectRegistrations|:

При этом в глобальном файле запуска приложения происходит регистрация этого класса в качестве основного способа разрешения 
зависимостей.

С полноценным кодом всей работы можно ознакомиться на CD диске \ref{app:CD}.
  
\conclusion
В рамках работы поставленная цель была достигнута. Для поиска центральных вершин был предложен 
генетический алгоритм, а кроме этого созданы программные приложения позволившие его исследовать.
Исходя из полученных результатов, можно сказать, что во многом время и качество работы алгоритма зависит от параметров
$p_m$, $p_c$ и $N$, и при правильно подобранных значениях алгоритм не уступает по своим характеристикам 
разработанным ранее алгоритмам. Кроме этого создано веб"=приложение для работы с генетическим алгоритмом.

\bibliographystyle{gost780uv}
\bibliography{thesis}

\appendix

\end{document}
