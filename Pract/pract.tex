\documentclass[bachelor, och, pract, times]{SCWorks}
\usepackage[T2A]{fontenc}
\usepackage[cp1251]{inputenc}
\usepackage{graphicx}
\usepackage[sort,compress]{cite}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{fancyvrb}
\usepackage{longtable}
\usepackage{listings}
\usepackage{array}
\usepackage[english,russian]{babel}


\usepackage[colorlinks=true]{hyperref}


\newcommand{\eqdef}{\stackrel {\rm def}{=}}
\newtheorem{lem}{Лемма}
\lstset{
	breaklines=true, 
	language=C, 
	numberstyle=\tiny, 
	numbers=left, 
	columns=flexible,
	keepspaces=false, 
	basicstyle=\small,
}

\begin{document}

\chair{математической кибернетики и компьютерных наук}


\title{Создание приложения для анализа генетического алгоритма поиска центральных вершин}

\course{4}
\group{411}

\napravlenie{02.03.02 "--- Фундаментальная информатика и информационные технологии}

\author{Власова Андрея Александровича}


\chtitle{к.\,ф.-м.\,н.}
\chname{С.\,В.\,Миронов}


\satitle{доцент, к.\,ф.-м.\,н.}
\saname{Ю.\,Н.\,Кондратова}

\patitle{доцент, к.\,ф.-м.\,н.} 
\paname{Ю.\,Н.\,Кондратова}

\term{2}

\practtype{учебная}

\duration{2}

\practStart{30.06.2017}
\practFinish{13.07.2017}


\date{2017}

\maketitle



\tableofcontents


% Раздел "Введение"
\intro
Введение


\section{Использование приложения}

\section{Описание технологий и архитектуры приложения}
В качестве языка программирования для решения поставленной задачи был выбран объектно"=ориентированный язык C\#. \cite{MSDN}
Вместе с тем для создания клиент"=серверного приложения был использован фреймворк \verb|ASP.NET MVC 5|, который позволяет 
создавать веб-приложения с использованием архитектуры \verb|MVC|. Кроме этого в качестве системы объектно"=реляционного 
отображения используется технология \verb|Entity Framework 6|. При этом приложение разделено на три слоя абстракции --- уровень 
доступа к данным, уровень бизнес"=логики и уровень визуального представления. 

\subsection{Структура базы данных}
Хранение графов в базе данных были созданы следующие таблицы: \verb|Graphs| и \verb|Edges|. 
При этом таблица \verb|Graphs| содержит следующие поля:
\begin{itemize}
    \item поле \verb|Id| (типа данных \verb|INT|) "--- уникальный идентификатор, внутренний ключ,
    \item поле \verb|N| (типа данных \verb|INT|) "--- количество вершин в графе, 
    \item поле \verb|M| (типа данных \verb|INT|) "--- количество ребер в графе,
    \item поле \verb|Name| (типа данных \verb|NVARCHAR|) "--- название графа,
    \item поле \verb|R| (типа данных \verb|INT|) "--- радиус графа.
\end{itemize}
Кроме этого таблица \verb|Edges| состоит из следующих полей: 
\begin{itemize}
    \item поле \verb|Id| (типа данных \verb|INT|) "--- уникальный идентификатор, внутренний ключ,
    \item поле \verb|V1| (типа данных \verb|INT|) "--- одна из вершин, которые соединяет ребро, 
    \item поле \verb|V1| (типа данных \verb|INT|) "--- вторая из вершин, которые соединяет ребро,
    \item поле \verb|Graph_Id| (типа данных \verb|INT|) "--- \verb|Id| графа, которому принадлежит ребро, внешний ключ.
\end{itemize}
Кроме этого для хранения зарегестрированных пользователей существует таблица \verb|Users|:
\begin{itemize}
    \item поле \verb|Id| (типа данных \verb|INT|) "--- уникальный идентификатор, внутренний ключ,
    \item поле \verb|Login| (типа данных \verb|NVARCHAR|) "--- логин пользователя,
    \item поле \verb|Password| (типа данных \verb|NVARCHAR|) "--- зашифрованный пароль пользователя.
\end{itemize}

Полная диаграмма таблиц представлена на рисунке \ref{fig:f1}:
\begin{figure}[!ht]
	\centering
	\includegraphics{pic/database_diagram.png}
	\caption{\label{fig:f1}	Диаграмма базы данных}
\end{figure}

Для создания базы данных используется технология \verb|Entity Framework|, вместе с чем использовался подход 
\verb|Code-first|, согласно которому были созданы классы \verb|Graph|, \verb|GraphInfo|, \verb|Edge|, \verb|User|, описывающие 
модели данных:
\begin{Verbatim}[fontsize=\small, numbers=left]
public class GraphInfo 
{
	public int Id { get; set; }
	public int N { get; set; }
	public int M { get; set; }
	public string Name { get; set; }
	public int R { get; set; }
}
\end{Verbatim}

\begin{Verbatim}[fontsize=\small, numbers=left]
public class Graph : GraphInfo 
{
	public ICollection<Edge> Edges { get; set; }
	public Graph()
	{
		Edges = new List<Edge>();
	}
}
\end{Verbatim}

\begin{Verbatim}[fontsize=\small, numbers=left]
public class Edge 
{
	public int Id { get; set; }
	public int V1 { get; set; }
	public int V2 { get; set; }
}
\end{Verbatim}
После этого фреймворк на основе созданных моделей сам генерирует таблицы в базе данных и ее структуру.

\subsection{Уровень доступа к данным}
Для гибкой и стандартизированной работы с базой данных был создан ряд интерфейсов,
в которые были вынесены основные методы для доступа к данным и их изменениям.
Классы, реализующие эти интерфейсы представляют собой уровень доступа к данным, при этом 
использование интерфейсов позволяет с легкостью изменять реализацию этих классов, а также упрощает 
процесс тестирования.

Далее приводится код основных интерфейсов, которые используются при работе с данными:
\begin{Verbatim}[fontsize=\small, numbers=left]
public interface IGraphDao
{
        IEnumerable<GraphInfo> GetAllGraphInfo();
        Graph GetById(int id);
        Graph Add(Graph graph);
}
\end{Verbatim}
  
\begin{Verbatim}[fontsize=\small, numbers=left]
public interface IUserDao
{
        User GetById(int id);
        User GetByName(string name);
        User Add(User user);
}
\end{Verbatim}

Вместе с тем для использования технологии \verb|Entity Framework| созданы классы \verb|GraphContext| и \verb|UserContext|, 
которые наследуются от класса \verb|System.Data.Entity.DbContext|, что позволяет получить возможность для легкого
доступа к базе данных без написания SQL запросов. Классы \verb|GraphContext| и \verb|UserContext| содержат в себе поля типа
\verb|DbSet<Graph>| и \verb|DbSet<User>|, через которые происходит добавление, чтение или изменение данных в базе данных.
Кроме этого в этих классах описан статический конструктор, внутри которого указан способ начальной инициализации базы данных, 
за счет классов \verb|UserContextInitializer| и \verb|GraphContextInitializer|. Эти классы наследуются от класса 
\verb|CreateDatabaseIfNotExists|, что позволяет фреймворку выполнить начальное заполнение данными, если база данных еще не 
существует, за счет кода, который описан в переопределенном методе \verb|Seed|. 
Внутри этого метода происходит чтение нескольких созданных графов из текстовых файлов, 
все это происходит внутри метода, описанного в классе \verb|GraphContextInitializer|, в этом же методе в классе 
\verb|UserContextInitializer| добавляется пользователь с логином \verb|admin| и паролем \verb|admin|. Полный код представлен в 
приложении [ссылка].
 
\subsection{Уровень бизнес-логики}
Уровень бизнес-логики представляет собой похожую структуру, как и уровень доступа данных "--- так же 
созданы ряд интерфейсов и классы, которые их реализуют. 
При этом многие из этих интерфейсов похожи на те, которые описаны в уровне доступа к данным, однако 
именно на этом уровне происходит запуск генетического алгоритма с различными параметрами и    
анализ загруженных графов.
С определением интерфейсов и классов реализующих бизнес-логику приложения можно ознакомиться в приложении [ссылка].
Классы \verb|GraphBL| и \verb|UserBL|, реализуют интерфейсы \verb|IGraphBL| и \verb|IUserBL|. Они содержат ссылки на объекты, 
реализующие интерфейсы \verb|IGraphDao| и \verb|IUserBL|, при 
этом эти объекты передаются в качестве параметров в соответствующие конструкторы. 
При добавлении нового пользователя происходит проверка на существование записи с таким же логином, а кроме этого происходит 
шифровка пароля. 

Также при добавлении нового графа в базу данных в классе, который отвечает за работу с моделью графа, происходит проверка графа 
на 
связность и его размеры. При неудачном прохождении проверки выбрасывается исключение, которое отлавливается на уровне 
представления.

Кроме этого для работы с генетическим алгоритмом создан интерфейс \verb|IAlgorithm|:
\begin{Verbatim}[fontsize=\small, numbers=left]
public interface IAlgorithm
    {
        FindingVertexResponse FindCentralVertex(Graph graph);
        ResearchAlgorithmResponse ResearchAlgorithm(ResearchRequest param);
    }
\end{Verbatim}

Интерфейс определяет набор методов, в которых будет реализована логика для работы с генетическим алгоритмом.
Вместе с тем класс \verb|Algorithm| реализует данный интерфейс и в нем содержится вся логика работы с алгоритмом "--- получение 
результатов поиска центральных вершин, замеры времени работы и процента неверно найденных решений.
 
Результаты измерений возвращаются из методов при помощи классов \verb|FindingVertexResponse| и \verb|ResearchAlgorithmResponse|:
\begin{Verbatim}[fontsize=\small, numbers=left]
public class FindingVertexResponse
{
	public int[] Center { get; set; }
	public int R { get; set; }
	public double Time { get; set; }
}
\end{Verbatim}

\begin{Verbatim}[fontsize=\small, numbers=left]
public class ResearchAlgorithmResponse
    {
        public double AvgTime { get; set; }
        public double Error { get; set; }
    }
\end{Verbatim}


\subsection{Уровень представления}
Так как проект представляет собой веб"=приложение, то уровень, отвечающий за пользовательский интерфейс реализован при помощи 
технологии \verb|ASP .NET MVC 5|. В связи с чем весь код этого уровня разделен на:
\begin{itemize}
    \item контроллеры, которые отвечают на HTTP запросы клиента с помощью представлений,
    \item представления, которые написаны с использованием технологии Razor, позволяющей внедрять серверный C\# код,
		\item модели данных, внутри которых происходит передача данных от клиента серверу и обратно.
\end{itemize}

\subsubsection{Контроллеры}
Для взаимодействия с клиентской частью приложения и обработки пользовательских данных было создано несколько
контроллеров: \verb|HomeController|, \verb|GraphController|, \verb|LoginController|, \verb|ResearchController|.

Класс \verb|HomeController| содержит один метод \verb|Index|, который отвечает на GET"=запрос и возвращает домашнюю страницу.

Класс \verb|GraphController| включает в себя методы, определяющие URL"=адреса при взаимодействии с которыми клиентской части 
приложения предоставляется возможность запускать генетический алгоритм для поиска центральных вершин или добавлять новый граф в 
базу данных. В целом данный контроллер ответственен за обработку следующих запросов:
\begin{itemize}
	\item \verb|/Graph| "--- обрабатывает GET"=запрос возвращает загрузочную страницу для поиска центральных вершин, 
	\item \verb|/Graph/FindCentralVertex| "--- обрабатывает POST"=запрос, в котором передается файл с графом, после чего запускается 
	генетический алгоритм. В качестве результата возвращается страница с сообщением об ошибке, которая могла произойти при 
	обработке запроса из"=за неверного формата данных в файле с графом, или слишком большого размера загружаемого графа, либо же 
	при успешном запуске возвращает страницу с результатами работы "--- радиус графа и возможные центральные вершины, 
	\item \verb|/Graph/Add| "--- обрабатывает GET"=запрос, который возвращает форму для загрузки графа в базу данных,
	\item \verb|/Graph/Add| "--- обрабатывает POST"=запрос, в котором пользователь предает на сервер для сохранения файл с графом и название 
	графа. При успешном добавлении перенаправляет пользователя на домашнюю страницу, при возможной ошибке "--- страницу с 
	описанием ошибки.
\end{itemize}

Класс \verb|ResearchController| содержит методы через которые пользователю предоставляется возможность запускать генетический 
алгоритм с различными параметрами ($p_c, p_m, N$), а также граф на котором будет тестироваться алгоритм.
Контроллер содержит следующие методы:
\begin{itemize}
	\item \verb|/Research/Index| "--- обрабатывает GET"=запрос и возвращает форму с выбором параметров для генетического 
	алгоритма, при этом в результат подгружаются описания графов, сохраненных в базе данных,
	\item \verb|/Research/ResearchAlgorithm| "--- обрабатывает POST"=запрос в который передаются выбранные параметры алгоритма и 
	выбранный граф.
\end{itemize}

В классе \verb|LoginController| определены методы, за счет которых происходит регистрация и аутентификация пользователей.
Пользователь, который вошел в систему получает возможность для добавления новых графов и добавление новых пользователей, по 
сути залогиненному пользователю предоставляются права администратора.
В контроллере \verb|LoginController| реализованы следующие методы:
\begin{itemize}
	\item \verb|/Login/Index| "--- обрабатывает GET"=запрос и возвращает форму заполнения для входа в систему,
	\item \verb|/Research/SignIn| "--- обрабатывает POST"=запрос в который передается логин и пароль. 
	В этом методе происходит валидация введенных данных, проверка принадлежности пароля введенному пользователю и при успешном 
	прохождении пользователю отправляется набор cookie"=данных, вследствие чего происходит аутентификация пользователя. 
	При неверном логине или пароле пользователю возвращается сообщение об ошибке, при успешном прохождении аутентификации "--- метод 
	возвращает переадресацию на домашнюю страницу,
	\item \verb|/Login/SignUp| "--- обрабатывает GET"=запрос и возвращает форму для регистрации нового пользователя,
	\item \verb|/Login/SignUp| "--- обрабатывает POST"=запрос и добавляет нового пользователя при успешном прохождении валидации 
	и отсутствии пользователя с таким же логином.
\end{itemize}

\subsubsection{Модели данных и валидация}
Основными классами, с помощью объектов которых происходит передача данным в контроллеры, \verb|AddGraphRequest|, 
\verb|CreateUserRequest|, \\ \verb|LoginUserRequest|, 
\verb|ResearchRequest|, при этом результаты вычислений возвращаются из контроллеров в виде представлений, которые 
представляют собой HTML разметку с внедрением данных переданных через классы \\ \verb|AlgorithmResultResponse|, 
\verb|FindingVertexResponse|, \\ \verb|ResearchAlgorithmResponse|. 

При этом очевидно, что при этом введенные пользовательские данные должны удовлетворять некоторым условиям.
Для того, чтобы передаваемые данные можно было проверить из любого участка кода для некоторых свойств
были использованы атрибуты валидации [ссылка] \verb|Required|, \verb|Compare|, \verb|StringLength|:
\begin{Verbatim}[fontsize=\small, numbers=left]
public class CreateUserRequest
    {
        [Required(ErrorMessage = "Введите логин")]
        [StringLength(50, MinimumLength = 3, 
        ErrorMessage = "Длина логина должна быть от 3 до 50 символов")]
        public string Login { get; set; }
        
        [Required(ErrorMessage = "Введите пароль")]
        [StringLength(50, MinimumLength = 3, 
        ErrorMessage = "Длина логина должна быть от 3 до 50 символов")]
        public string Password { get; set; }

        [Required(ErrorMessage = "Повторите пароль")]
        [Compare("Password", ErrorMessage = "Пароли не совпадают")]
        public string ConfirmPassword { get; set; }
    }
\end{Verbatim}

\begin{Verbatim}[fontsize=\small, numbers=left]
public class LoginUserRequest
    {
        [Required(ErrorMessage = "Введите логин")]
        public string Login { get; set; }

        [Required(ErrorMessage = "Введите пароль")]
        public string Password { get; set; }
    }
\end{Verbatim}

При таком использовании атрибутов валидации проверить модель на соответствие выдвинутым требованиям можно при помощи следующего 
кода:
\begin{Verbatim}[fontsize=\small, numbers=left]
if (ModelState.IsValid) {
	...
}
\end{Verbatim}
внутри любого из контроллеров, где \verb|ModelState| "--- свойство класса \verb|Controller|, которое инкапсулирует состояние 
модели, переданной в качестве параметра запроса. В случае неудачного прохождения валидации в свойство \verb|ModelState| при 
помощи метода \verb|AddModelError| добавляется сообщение об ошибке, которое затем будет вставлено в HTML разметку. 
Атрибут \verb|Requred| установлен для логина и пароля, вводимого пользователем, что гарантирует тот факт, что в базу данных не 
будет помещена запись с пустыми полями. В добавок к этому у свойства \verb|ConfirmPassword| утановлен атрибут \verb|Compare|, 
который требует, чтобы свойство, отвечающее за хранение пароля, совпадало с свойством, отвечающим за хранение повтора пароля. 
Также используется атрибут \verb|StringLength|, в котором устанавливаются минимальная и максимальная длина логина и пароля.

\subsubsection{Аутентификация}
Как уже отмечалось ранее доступ к возможности добавлять графы в базу данных и добавлять туда же новых пользователей имеют 
доступ только пользователи, которые вошли в систему. В связи с этим в качестве технологии аутентификации в созданном приложении 
используется аутентификация с помощью форм [ссылка]. 
Для ее включения в файл \verb|Web.config| были добавлены следующие строки:
\begin{Verbatim}
<authentication mode="Forms">
      <forms loginUrl="~/login" timeout="60" />
</authentication>
\end{Verbatim}
в которых указывается по какому адресу будет отправлен пользователь в случае, если он не имеет прав доступа к запрошенным 
ресурсам и время действия cookie"-файлов.
При успешном прохождении проверки на принадлежность пользователю введенного им пароля при помощи следующей строки кода 
клиентская часть получает cookie"=файлы, которые затем будут присоединяться ко всем остальным запросам:
\begin{Verbatim}
FormsAuthentication.SetAuthCookie(user.Login, true);
\end{Verbatim}
Для того, чтобы к определенным методам был доступ только аутентифицированным пользователям к каждому методу применяется атрибут 
\verb|Authorize|, который гарантирует проверку на доступность для пользователя этих методов.
При этом для пользователя вошедшего в систему несколько изменяется HTML разметка, что достигается при помощи 
использования свойства \verb|User.Identity.IsAuthenticated|.

\subsection{Шифровка паролей}
Очевидно, что хранение паролей пользователей в открытом виде 
представляет собой подход нарушающий основы требования к безопасности приложения. 
В связи с чем каждый пароль при регистрации пользователя хешируется и полученный хеш сохраняется в 
базе данных. Хеширование паролей происходит в классе \verb|Encryption| (см. приложение [ссылка]), где определены публичные 
методы \verb|CreatePassword| и \verb|CheckPassword|. 
Создание хеша пароля происходит при помощи объекта класса \verb|Rfc2898DeriveBytes| [ссылка]:
\begin{Verbatim}
var pbkdf2 = new Rfc2898DeriveBytes(password, salt, iterations);
byte[] hash = pbkdf2.GetBytes(hashSize);
\end{Verbatim}
В конструктор класса передается строка с паролем, <<соль>> "--- псевдослучайная последовательность байт, которая используется 
для повышения криптоустойчивости хеша и параметр, отвечающий за искусственную временную задержку, которая позволяет избежать 
попытки грубого перебора. 
В базу данных сохраняется полученный хеш и сгенерированная <<соль>>.
При проверки подлинности пароля из базы данных извлекается хеш c <<солью>>, после чего введенный пароль хешируется с сохраненной <<солью>> и результат сравнивается с тем, что было сохранено в базе данных.

\subsection{Внедрение зависимостей}
Ранее описывались независимые уровни, на которые разделено приложение, при этом гибкость и заменяемость каждого из уровней 
гарантируется описанием интерфейсов. Каждый из уровней содержит ссылки на объекты, которые реализуют тот или иной интерфейс при 
этом эти объекты передаются в качестве параметров в конструкторы. Для того, чтобы гарантировать тот факт, что во все 
конструкторы будут переданы одни и те же реализации интерфейсов и избежать дублирования кода в созданном приложении 
используется IoC"=контейнер \verb|Ninject|, который связывает интерфейсы с объектами, которые их реализуют и предоставлять их 
при необходимости.
Связывание интерфейсов и реализации происходит в методе класса \verb|NinjectRegistrations|:
\begin{Verbatim}
public class NinjectRegistrations : NinjectModule
    {
        public override void Load()
        {
            Bind<IUserDao>().To<UserDao>();
            Bind<IGraphDao>().To<GraphDao>();
            Bind<IAlgorithm>().To<Algorithm>();
            Bind<IGraphBL>().To<GraphBL>();
            Bind<IUserBL>().To<UserBL>();
        }
    }
\end{Verbatim}
При этом в глобальном файле запуска приложения происходит регистрация этого класса в качестве основного способа разрешения 
зависимостей (см. приложение [ссылка]).

\section{Работа с генетическим алгоритмом}
Для изолированного доступа к методам генетического алгоритма и для корректного измерения временных затрат, а так же для 
корректного чтения графов из текстовых файлов были созданы 
следующие классы: \verb|ExactAlgorithmCore|, \verb|GeneticAlgorithmCore|, \verb|GraphContext|, \verb|GraphParser|.

\subsubsection{Чтение графа из файла}
Ранее говорилось о том, что графы передаются на сервер в текстовых файлах, при этом формат данных этого файла должен быть 
следующим: на каждой строке указывается ровно два числа "--- начало и конец ребра, при этом нумерация вершин должна начинаться 
с 0 и идти по порядку, т. е. если в графе $N$ вершин, то максимальным числом в файле должно быть число $N - 1$ и встречаться 
все числа от 0 до $N - 1$. Кроме этого в файле не должно встречаться отрицательных чисел.
С целью гарантированно принимать только файлы с корректными графами был создан статический класс \verb|GraphParser|, в котором 
реализован статический метод \verb|ParseTxtFormat|. Метод принимает массив строк, читает их и создает объект класса 
\verb|Graph|, который возвращается в качестве результата. При этом если формат файла не удовлетворяет одному из описанных ранее 
требований метод выбрасывает исключение с сообщением о неверном формате данных, исключение отлавливается на уровне 
пользовательского интерфейса.

\subsubsection{Запуск алгоритма на графах}
При работе генетического алгоритма после запуска обхода в ширину такие результаты, как расстояние между вершинами и найденные  
кротчайшие пути сохраняются до окончания работы алгоритма, в связи с чем был создан класс \verb|GraphContext|, который 
инкапсулирует структуры данных, хранящие описанные сведения, появляющиеся в процессе работы. Класс позволяет найти 
эксцентриситет вершин при помощи алгоритма поиска в ширину, а также позволяет проверять граф на связность с помощью этого же 
алгоритма. Расстояния, найденные в ходе процесса определения эксцентриситета хранятся в матрице $N \times N$, а кроме этого
для хранения кротчайших путей используется такая же матрица, где каждым элементом является список вершин в пути. 
С полным кодом описанного класса можно ознакомиться в приложении [ссылка].

\subsubsection{Генетический алгоритм}
Сам генетический алгоритм реализован в классе \verb|GeneticAlgorithmCore|.
При создании объекта этого класса в конструктор передаются такие параметры, как объект типа \verb|Graph|, значение параметра 
для уровня вероятности мутации, параметр для уровня вероятности скрещивания и размер  популяции. После того, как объект этого 
класса создан у него можно вызвать метод \verb|StartAlgorithm|:
\begin{Verbatim}
public FindingVertexResponse StartAlgorithm() {
	Init();
	_watch.Start();
	for (int i = 0; i < _step; i++) {
		EvolutionStep();
	}
	_watch.Stop();

	FindingVertexResponse res = new FindingVertexResponse() {
		Time = _watch.ElapsedMilliseconds / (double)1000,  
	};
	GetBestResult(res);
	return res;
}
\end{Verbatim}
в котором происходит вызов метода ответственного за начальную инициализацию популяции генетического алгоритма, а также за 
создание нового объекта класса \verb|GraphContext|. После чего итерационно запускаются процессы мутации, скрещивания и 
естественного отбора. В качестве результата возвращается время работы алгоритма и найденные центральные вершины.

Кроме этого при добавлении нового графа необходимо выяснить его реальный радиус и с этой целью создан класс 
\verb|ExactAlgorithmCore|, который запускает алгоритм обхода в ширину, из каждой вершины, что позволяет гарантированно найти 
точный радиус графа.





\conclusion
Заключение 

\bibliographystyle{gost780uv}
\bibliography{thesis}


\appendix
\section{CD-диск с отчетом о выполненной работе}\label{app:CD}
На приложенном диске можно ознакомиться со следующими файлами:


\end{document}
