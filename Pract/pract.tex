\documentclass[bachelor, och, pract, times]{SCWorks}
\usepackage[T2A]{fontenc}
\usepackage[cp1251]{inputenc}
\usepackage{graphicx}
\usepackage[sort,compress]{cite}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{fancyvrb}
\usepackage{longtable}
\usepackage{listings}
\usepackage{array}
\usepackage[english,russian]{babel}

\usepackage[colorlinks=true]{hyperref}

\newcommand{\scale}{0.5}
\newcommand{\eqdef}{\stackrel {\rm def}{=}}
\newtheorem{lem}{Лемма}

\lstset{
	breaklines=true, 
	language=C, 
	numberstyle=\tiny, 
	numbers=left, 
	columns=flexible,
	keepspaces=false, 
	basicstyle=\small,
}


\begin{document}

\chair{математической кибернетики и компьютерных наук}


\title{Создание приложения для анализа генетического алгоритма поиска центральных вершин}

\course{4}
\group{411}

\napravlenie{02.03.02 "--- Фундаментальная информатика и информационные технологии}

\author{Власова Андрея Александровича}


\chtitle{к.\,ф.-м.\,н., доцент}
\chname{А.\,С.\,Иванов}


\satitle{к.\,ф.-м.\,н.}
\saname{С.\,В.\,Миронов}

\patitle{к.\,ф.-м.\,н.} 
\paname{С.\,В.\,Миронов}

\term{8}

\practtype{учебная}

\duration{2}

\practStart{01.05.2020}
\practFinish{14.05.2020}


\date{2020}

\maketitle

\tableofcontents


% Раздел "Введение"
\intro
Зачастую задачи, хорошо исследованные с точки зрения теории не всегда могут быть оптимально решены в реальных условиях.
Например, задача поиска центральных вершин в графах легко может быть решена при помощи классических алгоритмов 
\cite{APSP,Fast_Approximation,Fast_Radius,Aingworth}.
Вместе с тем не всегда затраты по времени, которые эти алгоритмы выдают могут быть приемлемы. В связи с этим очень часто с 
использованием точных алгоритмов совместно могут разрабатываться и применяться эвристические подходы,
в своей основе содержащие некоторую естественную идею, формализованную для решения той или иной задачи.

В частности к эвристическим алгоритмам относятся генетические алгоритмы, которые моделируют в своей работе 
эволюционный процесс за счет этапов мутации, скрещивания и естественного отбора.
Сам процесс создания и адаптации генетического алгоритма для той или иной задачи не всегда представляет собой большую задачу
для исследования. Как известно \cite{HOLLAND, PANCHENCO}, на работу любого генетического алгоритма ключевым образов влияют несколько 
факторов: параметр, отвечающий за вероятность мутации, параметр, связанный с вероятностью скрещивания и параметр,
 описывающий размер популяции. Именно подбор этих параметров для решения задачи может требовать большого изучения 
 и временных затрат, как вычислительной техники, так и исследователя.
Для задачи поиска центральных вершин был разработан генетический алгоритм, который необходимо 
проанализировать и выявить его сильные и слабые стороны, а так же 
требуется предоставить возможность его легко запускать с различными параметрами и на различных графах.

В связи с этим основной целью этой работы является создание приложения, позволяющего исследовать созданный алгоритм.
Для достижения данной цели были поставлены следующие задачи:
\begin{itemize}
	\item разработать способ загрузки и хранения графов,
	\item создать интерфейс, позволяющий пользователю запускать алгоритм,
	\item разработать систему регистрации для доступа пользователя к дополнительным возможностям приложения,
	\item создать гибкое программное решение, которое было бы легко изменять и использовать.
\end{itemize}

\section{Описание задачи}
В целом задачу поиска центральных вершин можно описать формулами и следующими словами. 
Существует невзвешенный неориентированный граф $G = (V, E)$, где $V$ "--- множество вершин, $E$ "--- множество ребер.

Тогда центральными вершинами будут являться те узлы, которые имеют минимальный эксцентриситет "--- длина кротчайшего пути 
до самой удаленной вершины в графе от заданной. Кроме этого вместе с центральными вершинами используется понятие радиуса 
графа "--- значение эксцентриситета на центральной вершине.

То есть всю задачу можно описать следующей формулой:

\[
	R = \min\limits_{x \, \in \, V} \max\limits_{y \, \in \, V} (d(x, y)),
\]
где $d(x, y)$ "--- расстояние между вершинами $x, y$; $R$ "--- радиус графа.

Так как граф невзвешенный, то длина кротчайшего пути определяется как число ребер в самом пути.

\section{Описание генетического алгоритма}
Генетический алгоритм в своей основе содержит итерационное выполнение генетических операторов преобразования,
которые изменяют популяцию и выводят ее в некоторое оптимальное решение.
Как уже говорилось ранее этими этапами является этап мутации, этап скрещивания и этап естественного отбора.
Все эти этапы реализуются в зависимости от решаемой задачи по"=разному. 
При решении задачи поиска центральных вершин была разработана следующая реализация генетического алгоритма.

\subsection{Генерация начальной популяции}
В качестве начальной популяции выбирается случайный набор вершин графа. При этом этот размер указывается в качестве 
параметра $N$.

\subsection{Этап мутации}
При работе этапа мутации алгоритм проходится по всей популяции и для каждой вершины внутри популяции находятся ее соседние вершины, после чего с учетном заданного параметра мутации $p_m$ из соседей выбирается один представитель, которые заменяет
рассматриваемый элемент.

\subsection{Этап скрещивания} 
Для работы оператора скрещивания был реализован следующий подход: из популяции выбирается два представителя, после чего 
между этими вершинами находится кротчайший путь и из этого пути извлекается одна из вершин, которая и представляет собой 
потомка для последующего поколения популяции. При этом оператор так же действует с учетом параметра, отвечающего за вероятность скрещивания $p_c$.

\subsection{Этап естественного отбора}
При реализации естественного отбора для каждой вершины в популяции в качестве функции оценки приспособленности
<<особи>> выступает значение эксцентриситета. Для каждой вершины находится ее эксцентриситет после чего происходит вероятностный отбор, при этом приоритет для попадания в следующее поколение отдается вершинам с меньшим эксцентриситетом.


\section{Описание приложения}
Приложение представляет собой веб"=сайт через который предоставляется возможность для работы с генетическим алгоритмом.
С одной стороны у пользователя есть доступ к исследованию алгоритма и его запуску с различными параметрами, а с другой 
пользователь может заняться исследованием собственного графа и запустить алгоритм на нем.

При входе в приложение пользователь попадает на главную страницу см. рисунок \ref{fig:f2}.
\begin{figure}[!ht]
	\centering
	\includegraphics[scale=\scale]{pic/main_page.png}
	\caption{\label{fig:f2}	Главная страница}
\end{figure}

На главной странице пользователь видит небольшое описание алгоритма и главным образом навигационную панель, которая 
находится 
наверху страницы. На этой навигационной панели находятся ссылки на страницу с формой для поиска центральных вершин, страницу с 
формой для запуска алгоритма с различными параметрами и на различных графах, а так же ссылка для входа зарегистрированных 
пользователей. 

После перехода на страницу входа (см. рисунок \ref{fig:f3}) пользователь может ввести свои логин и пароль и после успешной 
аутентификации он будет перенаправлен на главную страницу, при этом в навигационной панели появятся ссылки на страницу добавления новых пользователей, новых графов, а так же будет отображаться его логин (см. рисунок \ref{fig:f4})
\begin{figure}[!ht]
	\centering
	\includegraphics[scale=\scale]{pic/signin_page.png}
	\caption{\label{fig:f3}	Страница входа}
\end{figure}

\begin{figure}[!ht]
	\centering
	\includegraphics[scale=\scale]{pic/login_navbar.png}
	\caption{\label{fig:f4}	Навигационная панель после входа в систему}
\end{figure}

При переходе на страницу, с которой возможно загрузить граф для поиска радиуса, пользователю показывается форма, через которую 
загружается граф (см. рисунок \ref{fig:f5}).
\begin{figure}[!ht]
	\centering
	\includegraphics[scale=\scale]{pic/center_graph.png}
	\caption{\label{fig:f5}	Форма для загрузки графа с целью поиска радиуса}
\end{figure}

Похожая страница показывается пользователю при загрузке нового графа на сервер (см. рисунок \ref{fig:f8}).
\begin{figure}[!ht]
	\centering
	\includegraphics[scale=\scale]{pic/add_graph.png}
	\caption{\label{fig:f8}	Страница для добавления графа}
\end{figure}

Если пользователь не загрузит граф или загрузит файл в неверном формате, то получит страницу с сообщением об ошибке (см. 
рисунок \ref{fig:f6}, \ref{fig:f7}).
\begin{figure}[!ht]
	\centering
	\includegraphics[scale=\scale]{pic/error_page.png}
	\caption{\label{fig:f6}	Страница с сообщением об ошибке}
\end{figure}
\begin{figure}[!ht]
	\centering
	\includegraphics[scale=\scale]{pic/error_page2.png}
	\caption{\label{fig:f7}	Страница с сообщением об ошибке}
\end{figure}

При верно загруженном файле пользователю открывается страница, на которой отображаются результаты запуска алгоритма: время 
его работы, полученный радиус графа и возможные центральные вершины (см. рисунок \ref{fig:f9}).
\begin{figure}[!ht]
	\centering
	\includegraphics[scale=\scale]{pic/find_center_result.png}
	\caption{\label{fig:f9}	Страница с результатами поиска центральных вершин}
\end{figure}
Кроме этого у пользователя есть возможность запускать генетический алгоритм с различными параметрами (см. рисунок 
\ref{fig:f10}).
\begin{figure}[!ht]
	\centering
	\includegraphics[scale=\scale]{pic/research.png}
	\caption{\label{fig:f10} Форма для исследования параметров алгоритма}
\end{figure}
На форме находятся несколько ползунков, через которые можно выставить основные параметры генетического алгоритма, а также 
там же находится выпадающий список, в котором выбирается один из сохраненных графов. 
После того как пользователь выбрал соответствующие параметры и отправил форму на сервер с выбранными параметрами запускается 
алгоритм, причем несколько раз для того, чтобы получить эмпирическую оценку времени работы и процента неверных ответов.
Именно эти результаты показываются на форме, которая показывается пользователю после работы алгоритма (см. рисунок 
\ref{fig:f11}).
\begin{figure}[!ht]
	\centering
	\includegraphics[scale=\scale]{pic/research_result.png}
	\caption{\label{fig:f11} Форма с результатами исследования параметров алгоритма}
\end{figure}
Каждому зарегистрированному пользователю предоставляется возможность для добавления новых пользователей через 
соответствующую форму (см. рисунок \ref{fig:f12}). Данные которые вводит пользователь выдвигаются следующие требования: 
длина пароля и логина должна быть от 5 до 50 символов и пользователь с таким же логином не должен уже существовать в базе 
данных. Если эти условия не будут выполнены пользователь получит соответствующее сообщение об ошибке (см. рисунок 
\ref{fig:f13}).
\begin{figure}[!ht]
	\centering
	\includegraphics[scale=\scale]{pic/create_user_page.png}
	\caption{\label{fig:f12} Форма для регистрации нового пользователя}
\end{figure}

\begin{figure}[!ht]
	\centering
	\includegraphics[scale=\scale]{pic/create_user_error.png}
	\caption{\label{fig:f13} Форма с ошибкой при неверных данных для регистрации пользователя}
\end{figure}

\section{Описание технологий и архитектуры приложения}
В качестве языка программирования создания проекта был выбран объектно"=ориентированный язык C\#.
Вместе с тем для создания клиент"=серверного приложения был использован фреймворк \verb|ASP.NET MVC 5| \cite{ADAM_FRIMAN, MVC}, который 
позволяет создавать веб"=приложения с использованием архитектуры \verb|MVC|. Кроме этого в качестве системы 
объектно"=реляционного 
отображения используется технология \verb|Entity Framework 6| \cite{EF6}. При этом приложение разделено на три слоя 
абстракции "--- уровень доступа к данным, уровень бизнес"=логики и уровень визуального представления. 

\subsection{Структура базы данных}
Для создания базы данных используется технология \verb|Entity Framework 6|, вместе с чем используется подход 
\verb|Code-first|, согласно которому были созданы классы \verb|Graph|, \verb|GraphInfo|, \verb|Edge|, \verb|User|, 
описывающие модели данных:
\begin{Verbatim}[fontsize=\small, numbers=left]
public class GraphInfo 
{
	public int Id { get; set; }
	public int N { get; set; }
	public int M { get; set; }
	public string Name { get; set; }
	public int R { get; set; }
}
\end{Verbatim}

\begin{Verbatim}[fontsize=\small, numbers=left]
public class Graph : GraphInfo 
{
	public ICollection<Edge> Edges { get; set; }
	public Graph()
	{
		Edges = new List<Edge>();
	}
}
\end{Verbatim}

\begin{Verbatim}[fontsize=\small, numbers=left]
public class Edge 
{
	public int Id { get; set; }
	public int V1 { get; set; }
	public int V2 { get; set; }
}
\end{Verbatim}
После чего фреймворк на основании созданных моделей создал структуру базы данных и связи между таблицами.

Хранение графов в базе данных были созданы следующие таблицы: \verb|Graphs| и \verb|Edges|. 
При этом таблица \verb|Graphs| содержит следующие поля:
\begin{itemize}
    \item поле \verb|Id| (типа данных \verb|INT|) "--- уникальный идентификатор, внутренний ключ,
    \item поле \verb|N| (типа данных \verb|INT|) "--- количество вершин в графе, 
    \item поле \verb|M| (типа данных \verb|INT|) "--- количество ребер в графе,
    \item поле \verb|Name| (типа данных \verb|NVARCHAR|) "--- название графа,
    \item поле \verb|R| (типа данных \verb|INT|) "--- радиус графа.
\end{itemize}
Кроме этого таблица \verb|Edges| состоит из следующих полей: 
\begin{itemize}
    \item поле \verb|Id| (типа данных \verb|INT|) "--- уникальный идентификатор, внутренний ключ,
    \item поле \verb|V1| (типа данных \verb|INT|) "--- одна из вершин, которые соединяет ребро, 
    \item поле \verb|V1| (типа данных \verb|INT|) "--- вторая из вершин, которые соединяет ребро,
    \item поле \verb|Graph_Id| (типа данных \verb|INT|) "--- \verb|Id| графа, которому принадлежит ребро, внешний ключ.
\end{itemize}
Кроме этого для хранения зарегистрированных пользователей существует таблица \verb|Users|:
\begin{itemize}
    \item поле \verb|Id| (типа данных \verb|INT|) "--- уникальный идентификатор, внутренний ключ,
    \item поле \verb|Login| (типа данных \verb|NVARCHAR|) "--- логин пользователя,
    \item поле \verb|Password| (типа данных \verb|VARBINARY|) "--- зашифрованный пароль пользователя.
\end{itemize}

Полная диаграмма таблиц представлена на рисунке \ref{fig:f1}:
\begin{figure}[!ht]
	\centering
	\includegraphics{pic/database_diagram.png}
	\caption{\label{fig:f1}	Диаграмма базы данных}
\end{figure}

\subsection{Уровень доступа к данным}
Для гибкой и стандартизированной работы с базой данных был создан ряд интерфейсов,
в которые были вынесены основные методы для доступа к данным и их изменениям.
Классы, реализующие эти интерфейсы представляют собой уровень доступа к данным, при этом 
использование интерфейсов позволяет с легкостью изменять реализацию этих классов, а также упрощает 
процесс тестирования.

Далее приводится код основных интерфейсов, которые используются при работе с данными:
\begin{Verbatim}[fontsize=\small, numbers=left]
public interface IGraphDao
{
        IEnumerable<GraphInfo> GetAllGraphInfo();
        Graph GetById(int id);
        Graph Add(Graph graph);
}
\end{Verbatim}
  
\begin{Verbatim}[fontsize=\small, numbers=left]
public interface IUserDao
{
        User GetById(int id);
        User GetByName(string name);
        User Add(User user);
}
\end{Verbatim}

Вместе с тем для использования технологии \verb|Entity Framework| созданы классы \verb|GraphContext| и \verb|UserContext|, 
которые наследуются от класса \verb|System.Data.Entity.DbContext|, что позволяет получить возможность для легкого
доступа к базе данных без написания SQL запросов. Классы \verb|GraphContext| и \verb|UserContext| содержат в себе поля типа
\verb|DbSet<Graph>| и \verb|DbSet<User>|, через которые происходит добавление, чтение или изменение данных в базе данных.
Кроме этого в этих классах описан статический конструктор, внутри которого указан способ начальной инициализации базы данных, 
за счет классов \verb|UserContextInitializer| и \verb|GraphContextInitializer|. Эти классы наследуются от класса 
\verb|CreateDatabaseIfNotExists|, что позволяет фреймворку выполнить начальное заполнение данными, если база данных еще не 
существует, за счет кода, который описан в переопределенном методе \verb|Seed|. 
Внутри этого метода происходит чтение нескольких созданных графов из текстовых файлов, 
все это происходит внутри метода, описанного в классе \verb|GraphContextInitializer|, в этом же методе в классе 
\verb|UserContextInitializer| добавляется пользователь с логином \verb|admin| и паролем \verb|admin|. Полный код представлен в приложении \ref{app:dal}.
 
\subsection{Уровень бизнес-логики}
Уровень бизнес-логики представляет собой похожую структуру, как и уровень доступа данных "--- так же 
созданы ряд интерфейсов и классы, которые их реализуют. 
При этом многие из этих интерфейсов похожи на те, которые описаны в уровне доступа к данным, однако 
именно на этом уровне происходит запуск генетического алгоритма с различными параметрами и    
анализ загруженных графов.
С определением интерфейсов и классов реализующих бизнес-логику приложения можно ознакомиться в приложении \ref{app:bl}.
Классы \verb|GraphBL| и \verb|UserBL|, реализуют интерфейсы \verb|IGraphBL| и \verb|IUserBL|. Они содержат ссылки на объекты, 
реализующие интерфейсы \verb|IGraphDao| и \verb|IUserBL|, при 
этом эти объекты передаются в качестве параметров в соответствующие конструкторы. 
При добавлении нового пользователя происходит проверка на существование записи с таким же логином, а кроме этого происходит 
шифровка пароля. 

Также при добавлении нового графа в базу данных в классе, который отвечает за работу с моделью графа, происходит проверка графа на связность и его размеры. При неудачном прохождении проверки выбрасывается исключение, которое отлавливается на уровне представления.

Кроме этого для работы с генетическим алгоритмом создан интерфейс \verb|IAlgorithm|:
\begin{Verbatim}[fontsize=\small, numbers=left]
public interface IAlgorithm
    {
        FindingVertexResponse FindCentralVertex(Graph graph);
        ResearchAlgorithmResponse ResearchAlgorithm(ResearchRequest param);
    }
\end{Verbatim}

Интерфейс определяет набор методов, в которых будет реализована логика для работы с генетическим алгоритмом.
Вместе с тем класс \verb|Algorithm| реализует данный интерфейс и в нем содержится вся логика работы с алгоритмом "--- получение 
результатов поиска центральных вершин, замеры времени работы и процента неверно найденных решений.
 
Результаты измерений возвращаются из методов при помощи классов \verb|FindingVertexResponse| и \verb|ResearchAlgorithmResponse|:
\begin{Verbatim}[fontsize=\small, numbers=left]
public class FindingVertexResponse
{
	public int[] Center { get; set; }
	public int R { get; set; }
	public double Time { get; set; }
}
\end{Verbatim}

\begin{Verbatim}[fontsize=\small, numbers=left]
public class ResearchAlgorithmResponse
    {
        public double AvgTime { get; set; }
        public double Error { get; set; }
    }
\end{Verbatim}

Полный код классов уровня бизнес"=логики можно увидеть в приложении \ref{app:bl}.

\subsection{Уровень представления}
Так как проект представляет собой веб"=приложение, то уровень, отвечающий за пользовательский интерфейс реализован при помощи 
технологии \verb|ASP .NET MVC 5|. В связи с чем весь код этого уровня разделен на:
\begin{itemize}
    \item контроллеры, которые отвечают на HTTP запросы клиента с помощью представлений,
    \item представления, которые написаны с использованием технологии Razor, позволяющей внедрять серверный C\# код,
		\item модели данных, внутри которых происходит передача данных от клиента серверу и обратно.
\end{itemize}

\subsubsection{Контроллеры}
Для взаимодействия с клиентской частью приложения и обработки пользовательских данных было создано несколько
контроллеров: \verb|HomeController|, \verb|GraphController|, \verb|LoginController|, \verb|ResearchController|.

Класс \verb|HomeController| содержит один метод \verb|Index|, который отвечает на GET"=запрос и возвращает домашнюю страницу.

Класс \verb|GraphController| включает в себя методы, определяющие URL"=адреса при взаимодействии с которыми клиентской части 
приложения предоставляется возможность запускать генетический алгоритм для поиска центральных вершин или добавлять новый граф в 
базу данных. В целом данный контроллер ответственен за обработку следующих запросов:
\begin{itemize}
	\item \verb|/Graph| "--- обрабатывает GET"=запрос возвращает загрузочную страницу для поиска центральных вершин, 
	\item \verb|/Graph/FindCentralVertex| "--- обрабатывает POST"=запрос, в котором передается файл с графом, после чего запускается 
	генетический алгоритм. В качестве результата возвращается страница с сообщением об ошибке, которая могла произойти при 
	обработке запроса из"=за неверного формата данных в файле с графом, или слишком большого размера загружаемого графа, либо же 
	при успешном запуске возвращает страницу с результатами работы "--- радиус графа и возможные центральные вершины, 
	\item \verb|/Graph/Add| "--- обрабатывает GET"=запрос, который возвращает форму для загрузки графа в базу данных,
	\item \verb|/Graph/Add| "--- обрабатывает POST"=запрос, в котором пользователь предает на сервер для сохранения файл с графом и название 
	графа. При успешном добавлении перенаправляет пользователя на домашнюю страницу, при возможной ошибке "--- страницу с 
	описанием ошибки.
\end{itemize}

Класс \verb|ResearchController| содержит методы через которые пользователю предоставляется возможность запускать генетический 
алгоритм с различными параметрами ($p_c, p_m, N$), а также граф на котором будет тестироваться алгоритм.
Контроллер содержит следующие методы:
\begin{itemize}
	\item \verb|/Research/Index| "--- обрабатывает GET"=запрос и возвращает форму с выбором параметров для генетического 
	алгоритма, при этом в результат подгружаются описания графов, сохраненных в базе данных,
	\item \verb|/Research/ResearchAlgorithm| "--- обрабатывает POST"=запрос в который передаются выбранные параметры алгоритма и выбранный граф.
\end{itemize}

В классе \verb|LoginController| определены методы, за счет которых происходит регистрация и аутентификация пользователей.
Пользователь, который вошел в систему получает возможность для добавления новых графов и добавление новых пользователей, по 
сути залогиненному пользователю предоставляются права администратора.
В контроллере \verb|LoginController| реализованы следующие методы:
\begin{itemize}
	\item \verb|/Login/Index| "--- обрабатывает GET"=запрос и возвращает форму заполнения для входа в систему,
	\item \verb|/Research/SignIn| "--- обрабатывает POST"=запрос в который передается логин и пароль. 
	В этом методе происходит валидация введенных данных, проверка принадлежности пароля введенному пользователю и при успешном 
	прохождении пользователю отправляется набор cookie"=данных, вследствие чего происходит аутентификация пользователя. 
	При неверном логине или пароле пользователю возвращается сообщение об ошибке, при успешном прохождении аутентификации "--- метод 
	возвращает переадресацию на домашнюю страницу,
	\item \verb|/Login/SignUp| "--- обрабатывает GET"=запрос и возвращает форму для регистрации нового пользователя,
	\item \verb|/Login/SignUp| "--- обрабатывает POST"=запрос и добавляет нового пользователя при успешном прохождении валидации 
	и отсутствии пользователя с таким же логином.
\end{itemize}

Полный код контроллеров можно увидеть в приложении \ref{app:controllers}.

\subsubsection{Модели данных и валидация}
Основными классами, с помощью объектов которых происходит передача данным в контроллеры, \verb|AddGraphRequest|, 
\verb|CreateUserRequest|, \\ \verb|LoginUserRequest|, 
\verb|ResearchRequest|, при этом результаты вычислений возвращаются из контроллеров в виде представлений, которые 
представляют собой HTML разметку с внедрением данных переданных через классы \\ \verb|AlgorithmResultResponse|, 
\verb|FindingVertexResponse|, \\ \verb|ResearchAlgorithmResponse|. 

При этом очевидно, что при этом введенные пользовательские данные должны удовлетворять некоторым условиям.
Для того, чтобы передаваемые данные можно было проверить из любого участка кода для некоторых свойств
были использованы атрибуты валидации \cite{VALIDATIONS} \verb|Required|, \verb|Compare|, \verb|StringLength|:
\begin{Verbatim}[fontsize=\small, numbers=left]
public class CreateUserRequest
    {
        [Required(ErrorMessage = "Введите логин")]
        [StringLength(50, MinimumLength = 3, 
        ErrorMessage = "Длина логина должна быть от 3 до 50 символов")]
        public string Login { get; set; }
        
        [Required(ErrorMessage = "Введите пароль")]
        [StringLength(50, MinimumLength = 3, 
        ErrorMessage = "Длина логина должна быть от 3 до 50 символов")]
        public string Password { get; set; }

        [Required(ErrorMessage = "Повторите пароль")]
        [Compare("Password", ErrorMessage = "Пароли не совпадают")]
        public string ConfirmPassword { get; set; }
    }
\end{Verbatim}

\begin{Verbatim}[fontsize=\small, numbers=left]
public class LoginUserRequest
    {
        [Required(ErrorMessage = "Введите логин")]
        public string Login { get; set; }

        [Required(ErrorMessage = "Введите пароль")]
        public string Password { get; set; }
    }
\end{Verbatim}

При таком использовании атрибутов валидации проверить модель на соответствие выдвинутым требованиям можно при помощи следующего 
кода:
\begin{Verbatim}[fontsize=\small, numbers=left]
if (ModelState.IsValid) {
	...
}
\end{Verbatim}
внутри любого из контроллеров, где \verb|ModelState| "--- свойство класса \verb|Controller|, которое инкапсулирует состояние 
модели, переданной в качестве параметра запроса. В случае неудачного прохождения валидации в свойство \verb|ModelState| при 
помощи метода \verb|AddModelError| добавляется сообщение об ошибке, которое затем будет вставлено в HTML разметку. 
Атрибут \verb|Requred| установлен для логина и пароля, вводимого пользователем, что гарантирует тот факт, что в базу данных не 
будет помещена запись с пустыми полями. В добавок к этому у свойства \verb|ConfirmPassword| установлен атрибут 
\verb|Compare|, 
который требует, чтобы свойство, отвечающее за хранение пароля, совпадало с свойством, отвечающим за хранение повтора пароля. 
Также используется атрибут \verb|StringLength|, в котором устанавливаются минимальная и максимальная длина логина и пароля.

\subsubsection{Аутентификация}
Как уже отмечалось ранее доступ к возможности добавлять графы в базу данных и добавлять туда же новых пользователей имеют 
доступ только пользователи, которые вошли в систему. В связи с этим в качестве технологии аутентификации в созданном приложении 
используется аутентификация с помощью форм \cite{FORMS_AUTH}. 
Для ее включения в файл \verb|Web.config| были добавлены следующие строки:
\begin{Verbatim}[fontsize=\small, numbers=left]
<authentication mode="Forms">
      <forms loginUrl="~/login" timeout="60" />
</authentication>
\end{Verbatim}
в которых указывается по какому адресу будет отправлен пользователь в случае, если он не имеет прав доступа к запрошенным 
ресурсам и время действия cookie"-файлов.
При успешном прохождении проверки на принадлежность пользователю введенного им пароля при помощи следующей строки кода 
клиентская часть получает cookie"=файлы, которые затем будут присоединяться ко всем остальным запросам:
\begin{Verbatim}[fontsize=\small, numbers=left]
FormsAuthentication.SetAuthCookie(user.Login, true);
\end{Verbatim}
Для того, чтобы к определенным методам был доступ только аутентифицированным пользователям к каждому методу применяется атрибут 
\verb|Authorize|, который гарантирует проверку на доступность для пользователя этих методов.
При этом для пользователя вошедшего в систему несколько изменяется HTML разметка, что достигается при помощи 
использования свойства \verb|User.Identity.IsAuthenticated|.

\subsection{Шифровка паролей}
Очевидно, что хранение паролей пользователей в открытом виде 
представляет собой подход нарушающий основы требования к безопасности приложения. 
В связи с чем каждый пароль при регистрации пользователя хешируется и полученный хеш сохраняется в 
базе данных. Хеширование паролей происходит в классе \verb|Encryption| (см. приложение \ref{app:bl}), где определены публичные 
методы \verb|CreatePassword| и \verb|CheckPassword|. 
Создание хеша пароля происходит при помощи объекта класса \verb|Rfc2898DeriveBytes| \cite{Rfc2898DeriveBytes}:
\begin{Verbatim}[fontsize=\small, numbers=left]
var pbkdf2 = new Rfc2898DeriveBytes(password, salt, iterations);
byte[] hash = pbkdf2.GetBytes(hashSize);
\end{Verbatim}
В конструктор класса передается строка с паролем, <<соль>> "--- псевдослучайная последовательность байт, которая используется 
для повышения криптоустойчивости хеша и параметр, отвечающий за искусственную временную задержку, которая позволяет избежать 
попытки грубого перебора. 
В базу данных сохраняется полученный хеш и сгенерированная <<соль>>.
При проверки подлинности пароля из базы данных извлекается хеш c <<солью>>, после чего введенный пароль хешируется с сохраненной <<солью>> и результат сравнивается с тем, что было сохранено в базе данных.

\subsection{Внедрение зависимостей}
Ранее описывались независимые уровни, на которые разделено приложение, при этом гибкость и заменяемость каждого из уровней 
гарантируется описанием интерфейсов. Каждый из уровней содержит ссылки на объекты, которые реализуют тот или иной интерфейс при 
этом эти объекты передаются в качестве параметров в конструкторы. Для того, чтобы гарантировать тот факт, что во все 
конструкторы будут переданы одни и те же реализации интерфейсов и избежать дублирования кода в созданном приложении 
используется IoC"=контейнер \verb|Ninject|, который связывает интерфейсы с объектами, которые их реализуют и предоставлять их 
при необходимости.
Связывание интерфейсов и реализации происходит в методе класса \verb|NinjectRegistrations|:
\begin{Verbatim}[fontsize=\small, numbers=left]
public class NinjectRegistrations : NinjectModule
    {
        public override void Load()
        {
            Bind<IUserDao>().To<UserDao>();
            Bind<IGraphDao>().To<GraphDao>();
            Bind<IAlgorithm>().To<Algorithm>();
            Bind<IGraphBL>().To<GraphBL>();
            Bind<IUserBL>().To<UserBL>();
        }
    }
\end{Verbatim}
При этом в глобальном файле запуска приложения происходит регистрация этого класса в качестве основного способа разрешения 
зависимостей (см. приложение \ref{app:di}).

\section{Работа с генетическим алгоритмом}
Для изолированного доступа к методам генетического алгоритма и для корректного измерения временных затрат, а так же для 
корректного чтения графов из текстовых файлов были созданы 
следующие классы: \verb|ExactAlgorithmCore|, \verb|GeneticAlgorithmCore|, \verb|GraphContext|, \verb|GraphParser|.

\subsubsection{Чтение графа из файла}
Ранее говорилось о том, что графы передаются на сервер в текстовых файлах, при этом формат данных этого файла должен быть 
следующим: на каждой строке указывается ровно два числа "--- начало и конец ребра, при этом нумерация вершин должна начинаться 
с 0 и идти по порядку, т. е. если в графе $N$ вершин, то максимальным числом в файле должно быть число $N - 1$ и встречаться 
все числа от 0 до $N - 1$. Кроме этого в файле не должно встречаться отрицательных чисел.
С целью гарантированно принимать только файлы с корректными графами был создан статический класс \verb|GraphParser|, в котором 
реализован статический метод \verb|ParseTxtFormat|. Метод принимает массив строк, читает их и создает объект класса 
\verb|Graph|, который возвращается в качестве результата. При этом если формат файла не удовлетворяет одному из описанных ранее 
требований метод выбрасывает исключение с сообщением о неверном формате данных, исключение отлавливается на уровне 
пользовательского интерфейса.

\subsubsection{Запуск алгоритма на графах}
При работе генетического алгоритма после запуска обхода в ширину такие результаты, как расстояние между вершинами и найденные  
кротчайшие пути сохраняются до окончания работы алгоритма, в связи с чем был создан класс \verb|GraphContext|, который 
инкапсулирует структуры данных, хранящие описанные сведения, появляющиеся в процессе работы. Класс позволяет найти 
эксцентриситет вершин при помощи алгоритма поиска в ширину, а также позволяет проверять граф на связность с помощью этого же 
алгоритма. Расстояния, найденные в ходе процесса определения эксцентриситета хранятся в матрице $N \times N$, а кроме этого
для хранения кротчайших путей используется такая же матрица, где каждым элементом является список вершин в пути. 
С полным кодом описанного класса можно ознакомиться в приложении \ref{app:graph}.

\subsubsection{Генетический алгоритм}
Сам генетический алгоритм реализован в классе \verb|GeneticAlgorithmCore|.
При создании объекта этого класса в конструктор передаются такие параметры, как объект типа \verb|Graph|, значение параметра 
для уровня вероятности мутации, параметр для уровня вероятности скрещивания и размер  популяции. После того, как объект этого 
класса создан у него можно вызвать метод \verb|StartAlgorithm|:
\begin{Verbatim}[fontsize=\small, numbers=left]
public FindingVertexResponse StartAlgorithm() {
	Init();
	_watch.Start();
	for (int i = 0; i < _step; i++) {
		EvolutionStep();
	}
	_watch.Stop();

	FindingVertexResponse res = new FindingVertexResponse() {
		Time = _watch.ElapsedMilliseconds / (double)1000,  
	};
	GetBestResult(res);
	return res;
}
\end{Verbatim}
в котором происходит вызов метода ответственного за начальную инициализацию популяции генетического алгоритма, а также за 
создание нового объекта класса \verb|GraphContext|. После чего итерационно запускаются процессы мутации, скрещивания и 
естественного отбора. В качестве результата возвращается время работы алгоритма и найденные центральные вершины.

Кроме этого при добавлении нового графа необходимо выяснить его реальный радиус и с этой целью создан класс 
\verb|ExactAlgorithmCore|, который запускает алгоритм обхода в ширину, из каждой вершины, что позволяет гарантированно найти 
точный радиус графа.

Полноценный код всего приложения представлен на CD"=диске \ref{app:CD}.

\conclusion
В рамках выполнения практики была достигнута поставленная цель "--- создано веб"=приложение,
за счет которого существует возможность работать с генетическим алгоритмом поиска центральных вершин.
При этом приложение позволяет исследовать генетический алгоритм, выявлять его сильные и слабые стороны.

\bibliographystyle{gost780uv}
\bibliography{thesis}

\appendix
\section{Уровень доступа данных} \label{app:dal}
Далее приводится программный код основных файлов, описывающих уровень доступа к данным.
\lstinputlisting{code/dao/GraphContext.cs}
\lstinputlisting{code/dao/GraphDao.cs}
\lstinputlisting{code/dao/UserContext.cs}
\lstinputlisting{code/dao/UserContextInitializer.cs}
\lstinputlisting{code/dao/UserDao.cs}

\section{Уровень бизнес-логики} \label{app:bl}
Далее приводится программный код, за счет которого происходит реализация уровня бизнес"=логики.
\lstinputlisting{code/bl/Algorithm.cs}
\lstinputlisting{code/bl/Encryption.cs}
\lstinputlisting{code/bl/GraphBL.cs}
\lstinputlisting{code/bl/UserBL.cs}

\section{Уровень пользовательского интерфейса} \label{app:controllers}
Далее приводится описание основных классов"=контроллеров.
\lstinputlisting{code/controllers/GraphController.cs}
\lstinputlisting{code/controllers/HomeController.cs}
\lstinputlisting{code/controllers/LoginController.cs}
\lstinputlisting{code/controllers/ResearchController.cs}

\section{Внедрение зависимостей} \label{app:di}
Далее приводится программный код, который отвечает за внедрение зависимостей в приложении:
\lstinputlisting{code/di/NinjectRegistrations.cs}
\lstinputlisting{code/di/Global.asax.cs}

\section{Генетический алгоритм} \label{app:graph}
Классы, отвечающие за работу генетического алгоритма и работу с графами.
\lstinputlisting{code/ga/ExactAlgorithmCore.cs}
\lstinputlisting{code/ga/GeneticAlgorithmCore.cs}
\lstinputlisting{code/ga/GraphContext.cs}
\lstinputlisting{code/ga/GraphParser.cs}

\section{CD-диск с отчетом о выполненной работе}\label{app:CD}
На приложенном диске можно ознакомиться со следующими файлами:
\begin{description}
	\item[Папка \texttt{Pract}] "---   \LaTeX- вариант отчета о практике;
	\item[Папка \texttt{GAWeb}] "--- Visual"=Studio проект с полным кодом приложения;
\end{description}

\end{document}
